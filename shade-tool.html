<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shade Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f0f0;
        }

        .container {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .back-btn {
            background-color: #6c757d;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 3px;
            cursor: pointer;
            text-decoration: none;
            font-size: 14px;
        }

        .back-btn:hover {
            background-color: #5a6268;
        }

        .animation-container {
            text-align: center;
            margin-bottom: 20px;
            background-color: #f8f8f8;
            padding: 20px;
            border-radius: 5px;
            position: relative;
        }

        .frame-preview-container {
            position: relative;
            display: inline-block;
            border: 2px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
        }

        #frame-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            width: auto;
            height: auto;
        }

        .frame-image {
            display: none;
        }

        .frame-image.active {
            display: block;
        }

        .sprite-canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .sprite-canvas {
            position: absolute;
            top: 0px;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .animation-selector {
            margin-bottom: 10px;
        }

        .animation-selector select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }

        .control-group {
            background-color: #f8f8f8;
            padding: 15px;
            border-radius: 5px;
        }

        .control-group h3 {
            margin: 0 0 10px 0;
            color: #333;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .input-group label {
            min-width: 80px;
            font-weight: bold;
        }

        input[type="range"] {
            flex: 1;
        }

        input[type="number"] {
            width: 80px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }

        .play-pause-btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            width: 100%;
        }

        .play-pause-btn:hover {
            background-color: #0056b3;
        }

        .sprite-controls {
            background-color: #f8f8f8;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .sprite-controls h3 {
            margin: 0 0 15px 0;
            color: #333;
        }

        .color-list {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            background-color: #ffffff;
        }

        .color-item {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 8px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        .color-item:last-child {
            margin-bottom: 0;
        }

        .color-preview {
            width: 40px;
            height: 40px;
            border: 2px solid #ccc;
            border-radius: 5px;
            flex-shrink: 0;
        }

        .color-info {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .color-hex {
            font-family: monospace;
            font-size: 14px;
            font-weight: bold;
            color: #333;
        }

        .color-count {
            font-size: 12px;
            color: #666;
        }

        .arrow {
            font-size: 20px;
            color: #666;
            flex-shrink: 0;
        }

        .target-color-picker {
            width: 50px;
            height: 40px;
            border: 2px solid #ccc;
            border-radius: 5px;
            cursor: pointer;
            flex-shrink: 0;
        }

        .error-message {
            background-color: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            border: 1px solid #f5c6cb;
        }

        .loading-message {
            background-color: #d1ecf1;
            color: #0c5460;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            border: 1px solid #bee5eb;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>Shade Tool</h1>
            <a href="index.html" class="back-btn">‚Üê Back to Tools</a>
        </div>

        <div class="control-group">
            <h3>Playback Controls</h3>
            <button class="play-pause-btn" id="play-pause-btn">Play</button>

            <div class="input-group">
                <label>Frame:</label>
                <input type="range" id="frame-slider" min="0" max="149" value="0">
                <input type="number" id="frame-input" min="0" max="149" value="0">
            </div>
        </div>

        <div class="animation-container">
            <div class="frame-preview-container" id="frame-preview-container">
                <div id="frame-container"></div>
                <div class="sprite-canvas-container" id="sprite-canvas-container"></div>
            </div>
        </div>

        <div class="sprite-controls">
            <h3>Colors</h3>
            <div id="color-status" style="margin-bottom: 15px; font-size: 14px; color: #666;"></div>

            <div class="color-list" id="color-list">
                <!-- Colors will be dynamically populated here -->
            </div>
        </div>

        <div class="control-group">
            <h3>Timing Settings</h3>
            <div class="input-group">
                <label>Delay (ms):</label>
                <input type="range" id="delay-slider" min="10" max="1000" value="30">
                <input type="number" id="delay-input" min="10" max="1000" value="30">
            </div>

            <div class="input-group">
                <label>FPS:</label>
                <span id="fps-display">33.3</span>
            </div>
        </div>

        <div class="control-group">
            <h3>Animation Settings</h3>

            <div class="input-group">
                <label>Animation:</label>
                <select id="animation-select">
                    <option value="Walk">Walk</option>
                </select>
            </div>

            <div class="input-group">
                <label>Sprite Opacity:</label>
                <input type="number" id="sprite-opacity-input" class="opacity-input" value="70" min="0" max="100"
                    step="1">
                <span>%</span>
            </div>

            <div class="input-group">
                <label>
                    <input type="checkbox" id="show-frames-checkbox" checked>
                    Show Frames
                </label>
            </div>
        </div>
    </div>

    <script>
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;

            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }

            return {
                h: Math.round(h * 360),
                s: Math.round(s * 100),
                l: Math.round(l * 100)
            };
        }

        function hexToHsl(hex) {
            const rgb = hexToRgb(hex);
            return rgb ? rgbToHsl(rgb.r, rgb.g, rgb.b) : null;
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        function getRelativeLuminance(r, g, b) {
            // Convert RGB to linear RGB values
            const rsRGB = r / 255;
            const gsRGB = g / 255;
            const bsRGB = b / 255;

            const rLinear = rsRGB <= 0.03928 ? rsRGB / 12.92 : Math.pow((rsRGB + 0.055) / 1.055, 2.4);
            const gLinear = gsRGB <= 0.03928 ? gsRGB / 12.92 : Math.pow((gsRGB + 0.055) / 1.055, 2.4);
            const bLinear = bsRGB <= 0.03928 ? bsRGB / 12.92 : Math.pow((bsRGB + 0.055) / 1.055, 2.4);

            // Calculate relative luminance using the WCAG formula
            return 0.2126 * rLinear + 0.7152 * gLinear + 0.0722 * bLinear;
        }

        function getCachedLuminance(r, g, b, cache) {
            const key = `${r},${g},${b}`;
            if (cache.has(key)) {
                return cache.get(key);
            }
            const luminance = getRelativeLuminance(r, g, b);
            cache.set(key, luminance);
            return luminance;
        }

        function hexToLuminance(hex, cache) {
            if (cache && cache.has(hex)) {
                return cache.get(hex);
            }
            const rgb = hexToRgb(hex);
            const luminance = rgb ? getRelativeLuminance(rgb.r, rgb.g, rgb.b) : 0;
            if (cache) {
                cache.set(hex, luminance);
            }
            return luminance;
        }

        class ShadeTool {
            constructor() {
                this.currentFrame = 0;
                this.totalFrames = 150;
                this.delay = 30;
                this.isPlaying = false;
                this.animationId = null;
                this.currentAnimation = 'Walk';
                this.animations = [];
                this.animationData = {};

                this.frameWidth = 0;
                this.frameHeight = 0;
                this.frameElements = {};
                this.currentFrameElement = null;

                this.spriteCanvases = {};
                this.spriteElements = {};
                this.currentSpriteElement = null;
                this.showFrames = true;
                this.spriteOpacity = 70;

                this.originalColors = {};
                this.targetColors = {};
                this.originalSprites = {};
                this.spriteColorFrameMapping = {}; // Maps sprite colors to frame colors at matching positions
                this.spriteColorTargets = {}; // Maps sprite colors to {dark, light, split} settings

                // Performance optimization caches
                this.luminanceCache = new Map();
                this.colorCache = new Map();
                this.imageDataCache = new Map();
                this.colorMappingCache = new Map(); // Cache for color mappings
                this.debounceTimeout = null;

                this.initializeElements();
                this.bindEvents();
                this.loadAvailableAnimations();
                this.updateDisplays();

                setTimeout(() => {
                    this.createFrameElements();
                    this.loadSprites();
                }, 100);
            }

            initializeElements() {
                this.frameContainer = document.getElementById('frame-container');
                this.playPauseBtn = document.getElementById('play-pause-btn');
                this.frameSlider = document.getElementById('frame-slider');
                this.frameInput = document.getElementById('frame-input');
                this.delaySlider = document.getElementById('delay-slider');
                this.delayInput = document.getElementById('delay-input');
                this.fpsDisplay = document.getElementById('fps-display');
                this.animationSelect = document.getElementById('animation-select');
                this.spriteOpacityInput = document.getElementById('sprite-opacity-input');
                this.showFramesCheckbox = document.getElementById('show-frames-checkbox');
                this.spriteCanvasContainer = document.getElementById('sprite-canvas-container');
                this.framePreviewContainer = document.getElementById('frame-preview-container');
                this.colorList = document.getElementById('color-list');
                this.colorStatus = document.getElementById('color-status');
            }

            bindEvents() {
                this.playPauseBtn.addEventListener('click', () => this.togglePlayPause());

                this.frameSlider.addEventListener('input', (e) => {
                    this.setFrame(parseInt(e.target.value));
                });

                this.frameInput.addEventListener('change', (e) => {
                    this.setFrame(parseInt(e.target.value));
                });

                this.delaySlider.addEventListener('input', (e) => {
                    this.setDelay(parseInt(e.target.value));
                });

                this.delayInput.addEventListener('change', (e) => {
                    this.setDelay(parseInt(e.target.value));
                });

                this.animationSelect.addEventListener('change', (e) => {
                    this.switchAnimation(e.target.value);
                });

                this.showFramesCheckbox.addEventListener('change', (e) => {
                    this.showFrames = e.target.checked;
                    this.updateVisibility();
                });

                this.spriteOpacityInput.addEventListener('change', (e) => {
                    this.spriteOpacity = parseInt(e.target.value) || 0;
                    this.updateSpriteOpacity();
                });
            }

            setFrame(frame) {
                this.currentFrame = Math.max(0, Math.min(frame, this.totalFrames - 1));
                this.updateFrame();
                this.updateDisplays();
            }

            setDelay(delay) {
                this.delay = Math.max(10, Math.min(delay, 1000));
                this.delaySlider.value = this.delay;
                this.delayInput.value = this.delay;
                this.updateDisplays();

                if (this.isPlaying) {
                    this.stopAnimation();
                    this.startAnimation();
                }
            }

            updateFrame() {
                if (this.currentFrameElement) {
                    this.currentFrameElement.classList.remove('active');
                }

                if (this.currentSpriteElement) {
                    this.currentSpriteElement.style.display = 'none';
                }

                if (this.frameElements[this.currentAnimation] &&
                    this.frameElements[this.currentAnimation][this.currentFrame]) {
                    this.currentFrameElement = this.frameElements[this.currentAnimation][this.currentFrame];
                    if (this.showFrames) {
                        this.currentFrameElement.classList.add('active');
                    }
                }

                if (this.spriteElements[this.currentAnimation] &&
                    this.spriteElements[this.currentAnimation][this.currentFrame]) {
                    this.currentSpriteElement = this.spriteElements[this.currentAnimation][this.currentFrame];
                    this.currentSpriteElement.style.display = 'block';
                    this.currentSpriteElement.style.opacity = this.spriteOpacity / 100;
                }
            }

            createFrameElements() {
                this.frameContainer.innerHTML = '';
                this.currentFrameElement = null;

                if (!this.frameElements[this.currentAnimation]) {
                    this.frameElements[this.currentAnimation] = {};
                }

                const frameFiles = this.animationData[this.currentAnimation]?.frames || [];

                for (let frame = 0; frame < this.totalFrames; frame++) {
                    let img = this.frameElements[this.currentAnimation][frame];

                    if (!img) {
                        let frameSrc;
                        if (frameFiles.length > frame) {
                            frameSrc = `Source/${this.currentAnimation}/${frameFiles[frame]}`;
                        } else {
                            // Fallback to old pattern for backwards compatibility
                            const frameNumber = String(frame).padStart(3, '0');
                            frameSrc = `Source/${this.currentAnimation}/frame_${frameNumber}_delay-0.03s.gif`;
                        }

                        img = document.createElement('img');
                        img.className = 'frame-image';
                        img.src = frameSrc;
                        img.alt = `Frame ${frame}`;

                        if (frame === 0) {
                            img.onload = () => {
                                this.frameWidth = img.naturalWidth;
                                this.frameHeight = img.naturalHeight;
                                this.setContainerDimensions();
                            };
                        } else {
                            img.onload = () => {
                                if (!this.frameWidth || !this.frameHeight) {
                                    this.frameWidth = img.naturalWidth;
                                    this.frameHeight = img.naturalHeight;
                                    this.setContainerDimensions();
                                }
                            };
                        }

                        this.frameElements[this.currentAnimation][frame] = img;
                    }

                    this.frameContainer.appendChild(img);
                }

                this.updateFrame();
            }

            async loadSprites() {
                try {
                    this.colorStatus.textContent = 'Loading sprites...';
                    const response = await fetch(`/api/animations/${this.currentAnimation}/sprites`);
                    const data = await response.json();

                    if (data.success && data.sprites.length > 0) {
                        await this.createSpriteElements(data.sprites);
                        this.colorStatus.textContent = `Loaded ${data.sprites.length} sprites`;
                        // Auto-extract colors from sprites
                        this.extractColorsFromSprites();
                    } else {
                        this.colorStatus.textContent = 'No sprites found for this animation';
                        this.clearSpriteElements();
                    }
                } catch (error) {
                    console.error('Error loading sprites:', error);
                    this.colorStatus.textContent = 'Error loading sprites';
                    this.clearSpriteElements();
                }
            }

            createSpriteElements(sprites) {
                this.spriteCanvasContainer.innerHTML = '';

                if (!this.spriteElements[this.currentAnimation]) {
                    this.spriteElements[this.currentAnimation] = {};
                }

                if (!this.originalSprites[this.currentAnimation]) {
                    this.originalSprites[this.currentAnimation] = {};
                }

                const loadPromises = [];

                sprites.forEach(spriteInfo => {
                    const frameIndex = spriteInfo.frameIndex;
                    if (frameIndex >= 0 && frameIndex < this.totalFrames) {
                        const img = document.createElement('img');
                        img.className = 'sprite-canvas';
                        img.src = `Source/${this.currentAnimation}/sprites/${spriteInfo.filename}`;
                        img.alt = `Sprite ${frameIndex}`;
                        img.style.display = 'none';
                        img.style.imageRendering = 'pixelated';
                        img.style.imageRendering = 'crisp-edges';

                        // Create a promise that resolves when the image loads
                        const loadPromise = new Promise((resolve, reject) => {
                            img.onload = () => {
                                this.storeOriginalSprite(frameIndex, img);
                                resolve();
                            };
                            img.onerror = () => {
                                console.warn(`Failed to load sprite: ${spriteInfo.filename}`);
                                resolve(); // Resolve anyway to not block other sprites
                            };
                        });

                        loadPromises.push(loadPromise);
                        this.spriteElements[this.currentAnimation][frameIndex] = img;
                        this.spriteCanvasContainer.appendChild(img);
                    }
                });

                this.updateFrame();

                // Return a promise that resolves when all sprites are loaded
                return Promise.all(loadPromises);
            }

            storeOriginalSprite(frameIndex, img) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                canvas.width = img.naturalWidth || img.width;
                canvas.height = img.naturalHeight || img.height;
                ctx.drawImage(img, 0, 0);

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                this.originalSprites[this.currentAnimation][frameIndex] = imageData;
            }

            clearSpriteElements() {
                this.spriteCanvasContainer.innerHTML = '';
                if (this.spriteElements[this.currentAnimation]) {
                    this.spriteElements[this.currentAnimation] = {};
                }
                this.currentSpriteElement = null;
            }

            nextFrame() {
                this.currentFrame++;
                if (this.currentFrame >= this.totalFrames) {
                    this.currentFrame = 0;
                }
                this.updateFrame();
                this.updateDisplays();
            }

            togglePlayPause() {
                if (this.isPlaying) {
                    this.stopAnimation();
                } else {
                    this.startAnimation();
                }
            }

            startAnimation() {
                this.isPlaying = true;
                this.playPauseBtn.textContent = 'Pause';
                this.lastFrameTime = 0;

                const animate = (currentTime) => {
                    if (this.isPlaying) {
                        if (currentTime - this.lastFrameTime >= this.delay) {
                            this.nextFrame();
                            this.lastFrameTime = currentTime;
                        }
                        this.animationId = requestAnimationFrame(animate);
                    }
                };

                this.animationId = requestAnimationFrame(animate);
            }

            stopAnimation() {
                this.isPlaying = false;
                this.playPauseBtn.textContent = 'Play';
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            }

            updateDisplays() {
                this.frameSlider.value = this.currentFrame;
                this.frameInput.value = this.currentFrame;

                const fps = (1000 / this.delay).toFixed(1);
                this.fpsDisplay.textContent = fps;
            }

            async loadAvailableAnimations() {
                try {
                    const response = await fetch('/api/animations');
                    const data = await response.json();

                    if (data.success) {
                        this.animations = data.animations.map(anim => anim.name);
                        this.animationData = {};

                        data.animations.forEach(anim => {
                            this.animationData[anim.name] = {
                                frameCount: anim.frameCount,
                                frames: anim.frames || []
                            };
                        });

                        if (this.animations.includes('Walk')) {
                            this.currentAnimation = 'Walk';
                        } else if (this.animations.length > 0) {
                            this.currentAnimation = this.animations[0];
                        }

                        if (this.currentAnimation && this.animationData[this.currentAnimation]) {
                            this.totalFrames = this.animationData[this.currentAnimation].frameCount;
                        }

                        this.updateAnimationSelect();
                    } else {
                        this.animations = ['Walk'];
                        this.animationData = { 'Walk': { frameCount: 150, frames: [] } };
                        this.currentAnimation = 'Walk';
                        this.totalFrames = 150;
                        this.updateAnimationSelect();
                    }
                } catch (error) {
                    this.animations = ['Walk'];
                    this.animationData = { 'Walk': { frameCount: 150, frames: [] } };
                    this.currentAnimation = 'Walk';
                    this.totalFrames = 150;
                    this.updateAnimationSelect();
                }
            }

            updateAnimationSelect() {
                this.animationSelect.innerHTML = '';
                this.animations.forEach(animation => {
                    const option = document.createElement('option');
                    option.value = animation;
                    option.textContent = animation;
                    if (animation === this.currentAnimation) {
                        option.selected = true;
                    }
                    this.animationSelect.appendChild(option);
                });
            }

            async extractColorsFromFrames() {
                this.colorStatus.textContent = 'Extracting colors from animation frames...';

                try {
                    const frames = this.frameElements[this.currentAnimation];
                    if (!frames || Object.keys(frames).length === 0) {
                        this.colorStatus.textContent = 'No frames loaded to extract colors from';
                        this.renderColorList([]);
                        return;
                    }

                    const colorCounts = {};

                    for (const frameIndex in frames) {
                        const frameImg = frames[frameIndex];
                        if (!frameImg.complete) continue;

                        const colors = this.extractColorsFromImage(frameImg);

                        for (const hex in colors) {
                            if (colorCounts[hex]) {
                                colorCounts[hex] += colors[hex];
                            } else {
                                colorCounts[hex] = colors[hex];
                            }
                        }
                    }

                    // Store original frame colors
                    this.originalFrameColors = colorCounts;

                    // Sort colors by luminance (dark to light)
                    this.sortedColorsByLuminance = Object.keys(colorCounts).sort((a, b) => {
                        return hexToLuminance(a, this.luminanceCache) - hexToLuminance(b, this.luminanceCache);
                    });

                    // Set initial target colors to first and last colors in luminance range
                    if (this.sortedColorsByLuminance.length > 0) {
                        this.darkTargetColor = this.sortedColorsByLuminance[0];
                        this.lightTargetColor = this.sortedColorsByLuminance[this.sortedColorsByLuminance.length - 1];
                    }

                    this.updateColorMappingFromFrames();
                    this.renderNewColorList();
                    this.colorStatus.textContent = `Found ${Object.keys(colorCounts).length} unique colors from frames`;

                } catch (error) {
                    console.error('Error extracting colors:', error);
                    this.colorStatus.textContent = 'Error extracting colors from frames';
                    this.renderColorList([]);
                }
            }

            async extractColorsFromSprites() {
                this.colorStatus.textContent = 'Extracting colors from sprites and analyzing frame correspondence...';

                try {
                    const sprites = this.spriteElements[this.currentAnimation];
                    const frames = this.frameElements[this.currentAnimation];

                    if (!sprites || Object.keys(sprites).length === 0) {
                        this.colorStatus.textContent = 'No sprites loaded to extract colors from';
                        this.renderNewColorList();
                        return;
                    }

                    if (!frames || Object.keys(frames).length === 0) {
                        this.colorStatus.textContent = 'No frames loaded for correspondence analysis';
                        this.renderNewColorList();
                        return;
                    }

                    const colorCounts = {};
                    this.spriteColorFrameMapping = {};

                    for (const frameIndex in sprites) {
                        const spriteImg = sprites[frameIndex];
                        const frameImg = frames[frameIndex];

                        if (!spriteImg.complete || !frameImg.complete) continue;

                        // Extract sprite colors and their corresponding frame colors
                        const correspondence = this.extractSpriteFrameCorrespondence(spriteImg, frameImg);

                        // Accumulate sprite color counts
                        for (const hex in correspondence.spriteColors) {
                            if (colorCounts[hex]) {
                                colorCounts[hex] += correspondence.spriteColors[hex];
                            } else {
                                colorCounts[hex] = correspondence.spriteColors[hex];
                            }
                        }

                        // Store frame color correspondence for each sprite color
                        for (const spriteColor in correspondence.frameCorrespondence) {
                            if (!this.spriteColorFrameMapping[spriteColor]) {
                                this.spriteColorFrameMapping[spriteColor] = {};
                            }

                            const frameColors = correspondence.frameCorrespondence[spriteColor];
                            for (const frameColor in frameColors) {
                                if (this.spriteColorFrameMapping[spriteColor][frameColor]) {
                                    this.spriteColorFrameMapping[spriteColor][frameColor] += frameColors[frameColor];
                                } else {
                                    this.spriteColorFrameMapping[spriteColor][frameColor] = frameColors[frameColor];
                                }
                            }
                        }
                    }

                    // Reset color mappings
                    this.originalColors = colorCounts;
                    this.targetColors = {};
                    this.spriteColorTargets = {};

                    // Initialize sprite color targets with default values
                    for (const hex in colorCounts) {
                        this.spriteColorTargets[hex] = {
                            dark: hex,
                            light: hex,
                            split: 50
                        };
                    }

                    // Update all color mappings
                    this.updateAllColorMappings();
                    this.renderNewColorList();
                    this.colorStatus.textContent = `Found ${Object.keys(colorCounts).length} unique sprite colors`;

                } catch (error) {
                    console.error('Error extracting colors:', error);
                    this.colorStatus.textContent = 'Error extracting colors from sprites';
                    this.renderNewColorList();
                }
            }

            extractSpriteFrameCorrespondence(spriteImg, frameImg) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d', { willReadFrequently: true });

                const width = spriteImg.naturalWidth || spriteImg.width;
                const height = spriteImg.naturalHeight || spriteImg.height;

                canvas.width = width;
                canvas.height = height;

                // Draw sprite and get its pixel data
                ctx.drawImage(spriteImg, 0, 0);
                const spriteData = ctx.getImageData(0, 0, width, height);

                // Draw frame and get its pixel data
                ctx.clearRect(0, 0, width, height);
                ctx.drawImage(frameImg, 0, 0);
                const frameData = ctx.getImageData(0, 0, width, height);

                const spriteColors = {};
                const frameCorrespondence = {};

                for (let i = 0; i < spriteData.data.length; i += 4) {
                    const spriteR = spriteData.data[i];
                    const spriteG = spriteData.data[i + 1];
                    const spriteB = spriteData.data[i + 2];
                    const spriteA = spriteData.data[i + 3];

                    if (spriteA > 0) { // Only process non-transparent sprite pixels
                        const spriteHex = rgbToHex(spriteR, spriteG, spriteB);

                        // Count sprite color
                        spriteColors[spriteHex] = (spriteColors[spriteHex] || 0) + 1;

                        // Get corresponding frame color at the same position
                        const frameR = frameData.data[i];
                        const frameG = frameData.data[i + 1];
                        const frameB = frameData.data[i + 2];
                        const frameA = frameData.data[i + 3];

                        if (frameA > 0) { // Only count non-transparent frame pixels
                            const frameHex = rgbToHex(frameR, frameG, frameB);

                            if (!frameCorrespondence[spriteHex]) {
                                frameCorrespondence[spriteHex] = {};
                            }

                            frameCorrespondence[spriteHex][frameHex] = (frameCorrespondence[spriteHex][frameHex] || 0) + 1;
                        }
                    }
                }

                return {
                    spriteColors: spriteColors,
                    frameCorrespondence: frameCorrespondence
                };
            }

            extractColorsFromImage(img) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d', { willReadFrequently: true });

                canvas.width = img.naturalWidth || img.width;
                canvas.height = img.naturalHeight || img.height;

                ctx.drawImage(img, 0, 0);

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const colorCounts = {};

                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const a = data[i + 3];

                    if (a > 0) { // Only count non-transparent pixels
                        const hex = rgbToHex(r, g, b);
                        colorCounts[hex] = (colorCounts[hex] || 0) + 1;
                    }
                }

                return colorCounts;
            }

            renderNewColorList() {
                this.colorList.innerHTML = '';

                if (!this.originalColors || Object.keys(this.originalColors).length === 0) {
                    this.colorList.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No colors found. Load sprites to see available colors.</div>';
                    return;
                }

                // Sort sprite colors by pixel count (descending)
                const sortedEntries = Object.entries(this.originalColors).sort((a, b) => b[1] - a[1]);

                sortedEntries.forEach(([spriteHex, count]) => {
                    const item = document.createElement('div');
                    item.className = 'color-item';
                    item.style.flexDirection = 'column';
                    item.style.alignItems = 'stretch';
                    item.style.padding = '15px';

                    const targets = this.spriteColorTargets[spriteHex];
                    if (!targets) return;

                    // Get sorted frame colors for this sprite color
                    const frameColors = this.spriteColorFrameMapping[spriteHex] || {};
                    const sortedFrameColors = Object.keys(frameColors).sort((a, b) => {
                        return hexToLuminance(a, this.luminanceCache) - hexToLuminance(b, this.luminanceCache);
                    });

                    const frameColorPreview = sortedFrameColors.slice(0, 5).map(frameHex => {
                        const luminance = hexToLuminance(frameHex, this.luminanceCache);
                        return `<div style="display: inline-block; background-color: ${frameHex}; width: 20px; height: 20px; border: 1px solid #ccc; margin-right: 2px; title: '${frameHex} (L: ${luminance.toFixed(3)})'"></div>`;
                    }).join('');

                    item.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                            <div style="background-color: ${spriteHex}; width: 40px; height: 40px; border: 2px solid #ccc; border-radius: 5px; flex-shrink: 0;"></div>
                            <div style="flex-grow: 1;">
                                <div style="font-family: monospace; font-size: 14px; font-weight: bold; color: #333;">${spriteHex.toUpperCase()}</div>
                                <div style="font-size: 12px; color: #666;">${count} pixels</div>
                                <div style="font-size: 11px; color: #666; margin-top: 3px;">Frame colors: ${frameColorPreview}</div>
                            </div>
                        </div>

                        <div style="display: flex; align-items: center; gap: 15px; background-color: #f0f0f0; padding: 10px; border-radius: 5px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 12px; font-weight: bold;">Dark:</span>
                                <input type="color" value="${targets.dark}"
                                       onchange="shadeTool.updateSpriteTarget('${spriteHex}', 'dark', this.value)"
                                       style="width: 30px; height: 25px; border: 1px solid #ccc; border-radius: 3px; cursor: pointer;">
                            </div>

                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 12px; font-weight: bold;">Light:</span>
                                <input type="color" value="${targets.light}"
                                       onchange="shadeTool.updateSpriteTarget('${spriteHex}', 'light', this.value)"
                                       style="width: 30px; height: 25px; border: 1px solid #ccc; border-radius: 3px; cursor: pointer;">
                            </div>

                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 12px; font-weight: bold;">Split:</span>
                                <input type="number" value="${targets.split}" min="0" max="100"
                                       onchange="shadeTool.updateSpriteTarget('${spriteHex}', 'split', this.value)"
                                       style="width: 50px; padding: 2px; border: 1px solid #ccc; border-radius: 3px; font-size: 12px;">
                                <span style="font-size: 12px;">% dark</span>
                            </div>
                        </div>
                    `;

                    this.colorList.appendChild(item);
                });
            }

            renderColorList(colorEntries) {
                this.colorList.innerHTML = '';

                if (colorEntries.length === 0) {
                    this.colorList.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No colors found. Load sprites to see available colors.</div>';
                    return;
                }

                // Sort by pixel count (descending)
                const sortedEntries = colorEntries.sort((a, b) => b[1] - a[1]);

                sortedEntries.forEach(([hex, count]) => {
                    const item = document.createElement('div');
                    item.className = 'color-item';

                    item.innerHTML = `
                        <div class="color-preview" style="background-color: ${hex}"></div>
                        <div class="color-info">
                            <div class="color-hex">${hex.toUpperCase()}</div>
                            <div class="color-count">${count} pixels</div>
                        </div>
                        <div class="arrow">‚Üí</div>
                        <input type="color" class="target-color-picker" value="${this.targetColors[hex]}"
                               onchange="shadeTool.updateTargetColor('${hex}', this.value)">
                    `;

                    this.colorList.appendChild(item);
                });
            }

            updateSpriteTarget(spriteHex, property, value) {
                if (!this.spriteColorTargets[spriteHex]) return;

                if (property === 'split') {
                    this.spriteColorTargets[spriteHex][property] = Math.max(0, Math.min(100, parseInt(value) || 50));
                } else {
                    this.spriteColorTargets[spriteHex][property] = value;
                }

                this.updateColorMappingForSprite(spriteHex);

                // Debounce the expensive applyColorMapping operation
                clearTimeout(this.debounceTimeout);
                this.colorStatus.textContent = 'Processing color changes...';
                this.debounceTimeout = setTimeout(() => {
                    this.applyColorMapping();
                }, 250);
            }

            updateColorMappingForSprite(spriteHex) {
                // Clear cached mapping for this sprite color when updated
                this.colorMappingCache.delete(spriteHex);

                const targets = this.spriteColorTargets[spriteHex];
                if (!targets) return;

                // The targetColors mapping is no longer used for the simplified approach,
                // but we'll keep it for compatibility with existing code
                this.targetColors[spriteHex] = targets.dark; // Default for display purposes
            }

            updateAllColorMappings() {
                for (const spriteHex in this.spriteColorTargets) {
                    this.updateColorMappingForSprite(spriteHex);
                }
            }

            updateTargetColor(sourceHex, targetHex) {
                this.targetColors[sourceHex] = targetHex;
                this.applyColorMapping();
            }

            applyColorMapping() {
                // Apply color mapping to all sprite elements using original sprite data
                const originalSprites = this.originalSprites[this.currentAnimation];
                if (!originalSprites) return;

                // Process sprites in chunks to avoid blocking
                const frameIndices = Object.keys(originalSprites);
                this.processSpritesInChunks(frameIndices, 0);
            }

            processSpritesInChunks(frameIndices, index) {
                const CHUNK_SIZE = 3; // Process 3 sprites at a time
                const endIndex = Math.min(index + CHUNK_SIZE, frameIndices.length);

                for (let i = index; i < endIndex; i++) {
                    this.applyColorMappingToSprite(frameIndices[i]);
                }

                if (endIndex < frameIndices.length) {
                    // Use setTimeout with minimal delay to yield control
                    setTimeout(() => {
                        this.processSpritesInChunks(frameIndices, endIndex);
                    }, 5);
                } else {
                    // Processing complete, update current frame if needed
                    this.updateFrame();
                    this.colorStatus.textContent = `Applied color mapping to ${frameIndices.length} sprites`;
                }
            }

            applyColorMappingToSprite(frameIndex) {
                const originalImageData = this.originalSprites[this.currentAnimation][frameIndex];
                if (!originalImageData) return;

                // Get the corresponding frame image data for luminance analysis
                const frameImg = this.frameElements[this.currentAnimation][frameIndex];
                if (!frameImg || !frameImg.complete) return;

                // Extract frame image data
                const frameCanvas = document.createElement('canvas');
                const frameCtx = frameCanvas.getContext('2d', { willReadFrequently: true });
                frameCanvas.width = frameImg.naturalWidth || frameImg.width;
                frameCanvas.height = frameImg.naturalHeight || frameImg.height;
                frameCtx.drawImage(frameImg, 0, 0);
                const frameImageData = frameCtx.getImageData(0, 0, frameCanvas.width, frameCanvas.height);

                // Create a new canvas for the modified sprite
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                canvas.width = originalImageData.width;
                canvas.height = originalImageData.height;
                canvas.className = 'sprite-canvas';
                canvas.style.display = 'none';
                canvas.style.imageRendering = 'pixelated';
                canvas.style.imageRendering = 'crisp-edges';

                // Create new image data based on original
                const newImageData = ctx.createImageData(originalImageData.width, originalImageData.height);
                const originalData = originalImageData.data;
                const frameData = frameImageData.data;
                const newData = newImageData.data;

                // Pre-calculate sprite color mapping for efficiency using cache
                const colorMap = new Map();
                for (const spriteHex in this.spriteColorTargets) {
                    // Check if we have a cached mapping
                    if (this.colorMappingCache.has(spriteHex)) {
                        colorMap.set(spriteHex, this.colorMappingCache.get(spriteHex));
                        continue;
                    }

                    const targets = this.spriteColorTargets[spriteHex];
                    const frameColors = this.spriteColorFrameMapping[spriteHex] || {};
                    const sortedFrameColors = Object.keys(frameColors).sort((a, b) => {
                        return hexToLuminance(a, this.luminanceCache) - hexToLuminance(b, this.luminanceCache);
                    });

                    let thresholdLuminance = 0.5; // Default threshold
                    if (sortedFrameColors.length > 0) {
                        const splitIndex = Math.ceil(sortedFrameColors.length * targets.split / 100);
                        if (splitIndex < sortedFrameColors.length) {
                            const thresholdColor = sortedFrameColors[splitIndex - 1];
                            thresholdLuminance = hexToLuminance(thresholdColor, this.luminanceCache);
                        }
                    }

                    const mapping = {
                        darkRgb: hexToRgb(targets.dark),
                        lightRgb: hexToRgb(targets.light),
                        threshold: thresholdLuminance
                    };

                    // Cache the mapping
                    this.colorMappingCache.set(spriteHex, mapping);
                    colorMap.set(spriteHex, mapping);
                }

                // Apply color mapping with optimized pixel processing
                for (let i = 0; i < originalData.length; i += 4) {
                    const spriteR = originalData[i];
                    const spriteG = originalData[i + 1];
                    const spriteB = originalData[i + 2];
                    const spriteA = originalData[i + 3];

                    if (spriteA > 0) { // Only process non-transparent sprite pixels
                        const spriteHex = rgbToHex(spriteR, spriteG, spriteB);
                        const mapping = colorMap.get(spriteHex);

                        if (mapping) {
                            // Get the corresponding frame pixel at the same position
                            const frameR = frameData[i];
                            const frameG = frameData[i + 1];
                            const frameB = frameData[i + 2];
                            const frameA = frameData[i + 3];

                            let targetRgb = mapping.darkRgb; // Default to dark

                            if (frameA > 0) { // Only analyze non-transparent frame pixels
                                const frameLuminance = getCachedLuminance(frameR, frameG, frameB, this.luminanceCache);

                                // Simple threshold comparison
                                if (frameLuminance > mapping.threshold) {
                                    targetRgb = mapping.lightRgb;
                                }
                            }

                            // Apply the selected target color
                            if (targetRgb) {
                                newData[i] = targetRgb.r;
                                newData[i + 1] = targetRgb.g;
                                newData[i + 2] = targetRgb.b;
                                newData[i + 3] = spriteA;
                            } else {
                                // Fallback to original color
                                newData[i] = spriteR;
                                newData[i + 1] = spriteG;
                                newData[i + 2] = spriteB;
                                newData[i + 3] = spriteA;
                            }
                        } else {
                            // Keep original color if no mapping defined
                            newData[i] = spriteR;
                            newData[i + 1] = spriteG;
                            newData[i + 2] = spriteB;
                            newData[i + 3] = spriteA;
                        }
                    } else {
                        // Keep transparent pixels
                        newData[i] = spriteR;
                        newData[i + 1] = spriteG;
                        newData[i + 2] = spriteB;
                        newData[i + 3] = spriteA;
                    }
                }

                ctx.putImageData(newImageData, 0, 0);

                // Replace the current sprite element with the new canvas
                const oldElement = this.spriteElements[this.currentAnimation][frameIndex];
                if (oldElement && oldElement.parentNode) {
                    oldElement.parentNode.replaceChild(canvas, oldElement);
                    this.spriteElements[this.currentAnimation][frameIndex] = canvas;

                    if (parseInt(frameIndex) === this.currentFrame) {
                        this.currentSpriteElement = canvas;
                        this.updateFrame();
                    }
                }
            }

            updateVisibility() {
                if (this.currentFrameElement) {
                    if (this.showFrames) {
                        this.currentFrameElement.classList.add('active');
                    } else {
                        this.currentFrameElement.classList.remove('active');
                    }
                }

                if (this.currentSpriteElement) {
                    this.currentSpriteElement.style.opacity = this.spriteOpacity / 100;
                }
            }

            updateSpriteOpacity() {
                if (this.currentSpriteElement) {
                    this.currentSpriteElement.style.opacity = this.spriteOpacity / 100;
                }
            }

            setContainerDimensions() {
                if (this.frameWidth && this.frameHeight) {
                    this.frameContainer.style.width = this.frameWidth + 'px';
                    this.frameContainer.style.height = this.frameHeight + 'px';
                }
            }

            switchAnimation(animationName) {
                if (animationName === this.currentAnimation) return;

                if (this.currentSpriteElement) {
                    this.currentSpriteElement.style.display = 'none';
                    this.currentSpriteElement = null;
                }

                this.currentAnimation = animationName;

                if (!this.animationData) {
                    this.animationData = {};
                }

                if (this.animationData[animationName]) {
                    this.totalFrames = this.animationData[animationName].frameCount;
                } else {
                    this.animationData[animationName] = {
                        frameCount: 150,
                        frames: []
                    };
                    this.totalFrames = 150;
                }

                this.currentFrame = 0;

                this.frameSlider.max = this.totalFrames - 1;
                this.frameInput.max = this.totalFrames - 1;

                this.spriteCanvasContainer.innerHTML = '';
                this.originalColors = {};
                this.targetColors = {};
                this.originalSprites[animationName] = {};
                this.spriteColorFrameMapping = {};
                this.spriteColorTargets = {};
                this.colorStatus.textContent = '';

                // Clear performance caches
                this.luminanceCache.clear();
                this.colorCache.clear();
                this.imageDataCache.clear();
                this.colorMappingCache.clear();

                this.renderNewColorList();

                this.frameWidth = 0;
                this.frameHeight = 0;

                this.createFrameElements();
                this.loadSprites();
                this.updateDisplays();
            }
        }

        let shadeTool;
        document.addEventListener('DOMContentLoaded', () => {
            shadeTool = new ShadeTool();
        });
    </script>
</body>

</html>