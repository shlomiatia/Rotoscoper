<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Texture Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f0f0;
        }

        .container {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .back-btn {
            background-color: #6c757d;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 3px;
            cursor: pointer;
            text-decoration: none;
            font-size: 14px;
        }

        .back-btn:hover {
            background-color: #5a6268;
        }

        .image-container {
            text-align: center;
            margin-bottom: 20px;
            background-color: #f8f8f8;
            padding: 20px;
            border-radius: 5px;
            position: relative;
        }

        .image-preview-container {
            position: relative;
            display: inline-block;
            border: 2px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
            overflow-x: auto;
            overflow-y: hidden;
            max-width: 100%;
            height: auto;
        }

        #image-preview {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #overlay-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .control-group {
            background-color: #f8f8f8;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
        }

        .control-group h3 {
            margin: 0 0 10px 0;
            color: #333;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .input-group label {
            min-width: 80px;
            font-weight: bold;
        }

        .zoom-btn {
            background-color: #6c757d;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            min-width: 30px;
        }

        .zoom-btn:hover {
            background-color: #5a6268;
        }

        #zoom-display {
            min-width: 50px;
            text-align: center;
            font-weight: bold;
            color: #333;
        }

        .file-input-group {
            margin-bottom: 15px;
        }

        .file-input-label {
            display: inline-block;
            padding: 8px 16px;
            background-color: #007bff;
            color: white;
            border-radius: 3px;
            cursor: pointer;
        }

        .file-input-label:hover {
            background-color: #0056b3;
        }

        #file-input {
            display: none;
        }

        .info {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
        }

        .colors-container {
            margin-top: 15px;
            padding: 15px;
            background-color: white;
            border-radius: 5px;
            border: 1px solid #ddd;
        }

        .color-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px;
            margin-bottom: 5px;
            border: 1px solid transparent;
            border-radius: 3px;
        }

        .color-option:hover {
            background-color: #f8f8f8;
        }

        .color-preview {
            width: 20px;
            height: 20px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }

        .color-info {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .color-hex {
            font-family: monospace;
            font-size: 14px;
            font-weight: bold;
            color: #333;
            min-width: 70px;
        }

        .color-rgb {
            font-family: monospace;
            font-size: 12px;
            color: #666;
        }

        .color-count {
            font-size: 12px;
            color: #666;
            margin-left: auto;
        }

        .layers-container {
            margin-bottom: 15px;
            padding: 15px;
            background-color: white;
            border-radius: 5px;
            border: 1px solid #ddd;
        }

        .layer-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
            background-color: #f8f8f8;
        }

        .add-layer-btn {
            padding: 8px 16px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
            width: 100%;
            margin-top: 10px;
        }

        .add-layer-btn:hover:not(:disabled) {
            background-color: #218838;
        }

        .add-layer-btn:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            opacity: 0.65;
        }

        .layer-color-input {
            width: 50px;
            height: 30px;
            padding: 0;
            border: 1px solid #ddd;
            border-radius: 3px;
            cursor: pointer;
        }

        .hex-color-input {
            width: 70px;
            padding: 4px 6px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
            text-transform: uppercase;
        }

        .delete-layer-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 14px;
        }

        .delete-layer-btn:hover {
            background-color: #c82333;
        }

        .layer-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .direction-controls {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 0 10px;
            border-left: 1px solid #ddd;
            border-right: 1px solid #ddd;
        }

        .direction-label {
            display: flex;
            align-items: center;
            gap: 2px;
            font-size: 12px;
            color: #666;
            cursor: pointer;
        }

        .direction-radio {
            margin: 0;
            cursor: pointer;
        }

        .numeric-input {
            width: 50px;
            padding: 4px 6px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 12px;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>Texture Tool</h1>
            <a href="index.html" class="back-btn">← Back to Tools</a>
        </div>

        <div class="control-group">
            <div class="file-input-group">
                <label class="file-input-label">
                    Select Image
                    <input type="file" id="file-input" accept="image/*">
                </label>
                <div class="info" id="image-info"></div>
            </div>

            <div class="input-group">
                <label>Zoom:</label>
                <button id="zoom-out-btn" class="zoom-btn">-</button>
                <span id="zoom-display">100%</span>
                <button id="zoom-in-btn" class="zoom-btn">+</button>
            </div>
        </div>

        <div class="image-container">
            <div class="image-preview-container" id="image-preview-container">
                <img id="image-preview" style="display: none;">
                <canvas id="layers-canvas"></canvas>
                <canvas id="overlay-canvas"></canvas>
            </div>
            <div class="colors-container" id="colors-container" style="display: none;">
                <h3>Image Colors</h3>
                <button id="add-layer-btn" class="add-layer-btn" disabled>Add Layer</button>
                <div class="layers-container" id="layers-container" style="display: none;">
                    <h3>Layers</h3>
                    <div id="layer-rows"></div>
                </div>
                <div id="color-options"></div>
            </div>
        </div>
    </div>

    <script>
        function hexToRgb(hex) {
            // Remove the # if present
            hex = hex.replace(/^#/, '');
            
            // Parse the hex values
            const bigint = parseInt(hex, 16);
            return {
                r: (bigint >> 16) & 255,
                g: (bigint >> 8) & 255,
                b: bigint & 255
            };
        }

        const TextureTool = function() {
            const self = this;
            
            this.zoomLevel = 100;
            this.maxZoom = 1000;
            this.minZoom = 25;
            this.zoomLevels = [25, 50, 75, 100, 125, 150, 200, 300, 400, 500, 600, 700, 800, 900, 1000];
            this.selectedColor = null;
            this.colorMap = new Map(); // Map to store colors and their counts
            this.colorLayers = new Map(); // Map to store layers for each color
            this.canvasPool = []; // Pool of reusable canvases
            this.nextLayerId = 1; // Counter for generating unique layer IDs
            
            this.initializeElements = function() {
                this.fileInput = document.getElementById('file-input');
                this.imagePreview = document.getElementById('image-preview');
                this.imageInfo = document.getElementById('image-info');
                this.zoomDisplay = document.getElementById('zoom-display');
                this.zoomInBtn = document.getElementById('zoom-in-btn');
                this.zoomOutBtn = document.getElementById('zoom-out-btn');
                this.colorsContainer = document.getElementById('colors-container');
                this.colorOptions = document.getElementById('color-options');
                this.overlayCanvas = document.getElementById('overlay-canvas');
                this.overlayCtx = this.overlayCanvas.getContext('2d');
                this.layersCanvas = document.getElementById('layers-canvas');
                this.layersCtx = this.layersCanvas.getContext('2d');
                this.layersContainer = document.getElementById('layers-container');
                this.layerRows = document.getElementById('layer-rows');
                this.addLayerBtn = document.getElementById('add-layer-btn');

                // Initialize color layers map and canvas pool
                this.colorLayers = new Map();
                this.canvasPool = [];

                // Configure the layers canvas
                this.layersCanvas.style.position = 'absolute';
                this.layersCanvas.style.top = '0';
                this.layersCanvas.style.left = '0';
                this.layersCanvas.style.pointerEvents = 'none';
                // Set pixelated rendering for both canvases
                [this.layersCanvas, this.overlayCanvas].forEach(canvas => {
                    canvas.style.imageRendering = 'pixelated';
                    canvas.style.imageRendering = '-moz-crisp-edges';
                    canvas.style.imageRendering = 'crisp-edges';
                });
            };
            
            this.updateLayerColorFromHex = function(layerId, sourceColorHex, hexValue) {
                // Validate and normalize hex color
                let normalizedHex = hexValue.trim().toUpperCase();

                // Add # if missing
                if (!normalizedHex.startsWith('#')) {
                    normalizedHex = '#' + normalizedHex;
                }

                // Validate hex format
                const hexRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
                if (!hexRegex.test(normalizedHex)) {
                    // If invalid, revert to current color
                    const layers = this.colorLayers.get(sourceColorHex) || [];
                    const layer = layers.find(l => l.id === layerId);
                    if (layer) {
                        const toolbar = this.layersContainer.querySelector(`[data-layer-id="${layerId}"][data-color-hex="${sourceColorHex}"]`);
                        if (toolbar) {
                            const hexInput = toolbar.querySelector('.hex-color-input');
                            const colorInput = toolbar.querySelector('.layer-color-input');
                            if (hexInput && colorInput) {
                                hexInput.value = layer.color.toUpperCase();
                                colorInput.value = layer.color;
                            }
                        }
                    }
                    return;
                }

                // Convert 3-digit hex to 6-digit
                if (normalizedHex.length === 4) {
                    normalizedHex = '#' + normalizedHex[1] + normalizedHex[1] +
                                      normalizedHex[2] + normalizedHex[2] +
                                      normalizedHex[3] + normalizedHex[3];
                }

                // Find layer and toolbar elements
                const layers = this.colorLayers.get(sourceColorHex) || [];
                const layer = layers.find(l => l.id === layerId);
                if (!layer) return;

                // Update the layer color
                this.updateLayerColor(layerId, sourceColorHex, normalizedHex);

                // Update UI controls
                const toolbar = this.layersContainer.querySelector(`[data-layer-id="${layerId}"][data-color-hex="${sourceColorHex}"]`);
                if (toolbar) {
                    const hexInput = toolbar.querySelector('.hex-color-input');
                    const colorInput = toolbar.querySelector('.layer-color-input');
                    if (hexInput && colorInput) {
                        hexInput.value = normalizedHex;
                        colorInput.value = normalizedHex;
                    }
                }
            };

            this.bindEvents = function() {
                this.fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
                this.zoomInBtn.addEventListener('click', () => this.zoomIn());
                this.zoomOutBtn.addEventListener('click', () => this.zoomOut());
                window.addEventListener('resize', () => this.updateZoom());
                this.addLayerBtn.addEventListener('click', () => this.addLayer());
            };
            
            this.deleteLayer = function(layerId, colorHex) {
                const layers = this.colorLayers.get(colorHex);
                if (!layers) return;

                const layerIndex = layers.findIndex(l => l.id === layerId);
                if (layerIndex === -1) return;

                // Get the layer and remove it from the array
                const layer = layers[layerIndex];
                layers.splice(layerIndex, 1);

                // Return the canvas to the pool after clearing it
                const ctx = layer.canvas.getContext('2d');
                ctx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
                this.canvasPool.push(layer.canvas);

                // Remove the layer row from UI
                const layerRow = this.layerRows.querySelector(`[data-layer-id="${layerId}"][data-color-hex="${colorHex}"]`);
                if (layerRow) {
                    layerRow.remove();
                }

                // If no more layers for this color, remove the color entry
                if (layers.length === 0) {
                    this.colorLayers.delete(colorHex);
                }

                // Update the display
                this.updateLayerDisplay();

                // Hide layers container if no layers for current color
                if (this.selectedColor && (!this.colorLayers.has(this.selectedColor.hex) || 
                    this.colorLayers.get(this.selectedColor.hex).length === 0)) {
                    this.layersContainer.style.display = 'none';
                }
            };

            this.addLayer = function() {
                if (!this.selectedColor) return;
                
                const layerId = this.nextLayerId++;
                
                // Get or create canvas from pool
                let canvas;
                if (this.canvasPool.length > 0) {
                    canvas = this.canvasPool.pop();
                } else {
                    canvas = document.createElement('canvas');
                    canvas.width = this.imagePreview.naturalWidth;
                    canvas.height = this.imagePreview.naturalHeight;
                }
                
                const layer = {
                    id: layerId,
                    color: this.selectedColor.hex, // Use selected color as initial color
                    sourceColor: this.selectedColor,
                    canvas: canvas
                };
                
                // Create initial color replacement
                this.updateLayerCanvas(layer);
                
                // Store the layer for this color
                if (!this.colorLayers.has(this.selectedColor.hex)) {
                    this.colorLayers.set(this.selectedColor.hex, []);
                }
                this.colorLayers.get(this.selectedColor.hex).push(layer);
                
                // Create and add the layer UI row
                const layerRow = document.createElement('div');
                layerRow.className = 'layer-row';
                layerRow.dataset.layerId = layerId;
                layerRow.dataset.colorHex = this.selectedColor.hex;
                
                // Color picker input
                const colorInput = document.createElement('input');
                colorInput.type = 'color';
                colorInput.className = 'layer-color-input';
                colorInput.value = layer.color;

                // Hex color input
                const hexInput = document.createElement('input');
                hexInput.type = 'text';
                hexInput.className = 'hex-color-input';
                hexInput.value = layer.color.toUpperCase();
                hexInput.maxLength = 7;
                hexInput.placeholder = '#RRGGBB';

                // Delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-layer-btn';
                deleteBtn.innerHTML = '&times;'; // × symbol
                deleteBtn.title = 'Delete Layer';
                deleteBtn.onclick = () => this.deleteLayer(layerId, this.selectedColor.hex);

                // Sync color picker and hex input
                colorInput.addEventListener('input', (e) => {
                    hexInput.value = e.target.value.toUpperCase();
                });

                colorInput.addEventListener('change', (e) => {
                    const color = e.target.value.toUpperCase();
                    hexInput.value = color;
                    this.updateLayerColor(layer.id, this.selectedColor.hex, color);
                });

                hexInput.addEventListener('input', (e) => {
                    let value = e.target.value.toUpperCase();
                    if (value.length === 6 && !value.startsWith('#')) {
                        value = '#' + value;
                        e.target.value = value;
                    }
                });

                hexInput.addEventListener('change', (e) => {
                    let value = e.target.value;
                    // Add # if missing
                    if (!value.startsWith('#')) {
                        value = '#' + value;
                    }
                    // Update the color everywhere
                    this.updateLayerColorFromHex(layer.id, this.selectedColor.hex, value);
                    colorInput.value = value; // Update color picker
                    hexInput.value = value.toUpperCase(); // Ensure uppercase format
                });

                // Create container for all controls
                const controlsDiv = document.createElement('div');
                controlsDiv.className = 'layer-controls';

                // Color controls
                controlsDiv.appendChild(colorInput);
                controlsDiv.appendChild(hexInput);

                // Direction radio buttons
                const directionDiv = document.createElement('div');
                directionDiv.className = 'direction-controls';

                const directions = ['full', 'left', 'right', 'top', 'bottom'];
                directions.forEach((direction, index) => {
                    const label = document.createElement('label');
                    label.className = 'direction-label';
                    
                    const radio = document.createElement('input');
                    radio.type = 'radio';
                    radio.name = `direction-${layerId}`;
                    radio.value = direction;
                    radio.className = 'direction-radio';
                    radio.checked = direction === 'full';
                    
                    // Add change event listener
                    radio.addEventListener('change', () => {
                        if (radio.checked) {
                            // Clear existing pixels before applying new direction
                            const layerCtx = layer.canvas.getContext('2d');
                            layerCtx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
                            // Update the layer with new direction
                            this.updateLayerCanvas(layer);
                            this.updateLayerDisplay();
                        }
                    });
                    
                    const text = document.createElement('span');
                    text.textContent = direction.charAt(0).toUpperCase() + direction.slice(1);
                    
                    label.appendChild(radio);
                    label.appendChild(text);
                    directionDiv.appendChild(label);
                });

                controlsDiv.appendChild(directionDiv);

                // Numeric input
                const numericInput = document.createElement('input');
                numericInput.type = 'number';
                numericInput.className = 'numeric-input';
                numericInput.value = '0';
                numericInput.min = '0';

                // Add change and input event listeners
                numericInput.addEventListener('change', () => {
                    // Clear existing pixels before applying new value
                    const layerCtx = layer.canvas.getContext('2d');
                    layerCtx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
                    // Update the layer with new value
                    this.updateLayerCanvas(layer);
                    this.updateLayerDisplay();
                });

                // Also update while typing
                numericInput.addEventListener('input', () => {
                    // Clear existing pixels before applying new value
                    const layerCtx = layer.canvas.getContext('2d');
                    layerCtx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
                    // Update the layer with new value
                    this.updateLayerCanvas(layer);
                    this.updateLayerDisplay();
                });

                controlsDiv.appendChild(numericInput);

                // Delete button
                controlsDiv.appendChild(deleteBtn);

                // Add all controls to the layer row
                layerRow.appendChild(controlsDiv);
                this.layerRows.insertBefore(layerRow, this.layerRows.firstChild);
                this.layersContainer.style.display = 'block';
                
                // Update display
                this.updateLayerDisplay();
            };
            
            this.findBoundingBoxes = function(pixels, sourceRgb, width, height) {
                const visited = new Array(width * height).fill(false);
                const regions = [];

                const isMatchingColor = (index) => {
                    return pixels[index] === sourceRgb.r &&
                           pixels[index + 1] === sourceRgb.g &&
                           pixels[index + 2] === sourceRgb.b;
                };

                // Flood fill to find connected components
                const floodFill = (startX, startY) => {
                    const box = { minX: startX, minY: startY, maxX: startX, maxY: startY };
                    const pixelsByRow = new Map();
                    const stack = [[startX, startY]];
                    
                    visited[startY * width + startX] = true;

                    while (stack.length > 0) {
                        const [x, y] = stack.pop();
                        
                        // Update bounding box
                        box.minX = Math.min(box.minX, x);
                        box.minY = Math.min(box.minY, y);
                        box.maxX = Math.max(box.maxX, x);
                        box.maxY = Math.max(box.maxY, y);

                        // Add pixel to row collection
                        if (!pixelsByRow.has(y)) {
                            pixelsByRow.set(y, []);
                        }
                        pixelsByRow.get(y).push(x);

                        // Check orthogonally adjacent pixels
                        const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                        for (const [dx, dy] of directions) {
                            const newX = x + dx;
                            const newY = y + dy;
                            
                            if (newX >= 0 && newX < width && 
                                newY >= 0 && newY < height && 
                                !visited[newY * width + newX]) {
                                
                                const index = (newY * width + newX) * 4;
                                if (isMatchingColor(index)) {
                                    stack.push([newX, newY]);
                                    visited[newY * width + newX] = true;
                                }
                            }
                        }
                    }

                    // Sort pixels in each row
                    pixelsByRow.forEach(pixels => pixels.sort((a, b) => a - b));

                    return {
                        box,
                        pixelsByRow
                    };
                };

                // Find all connected components
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (!visited[y * width + x]) {
                            const index = (y * width + x) * 4;
                            if (isMatchingColor(index)) {
                                const region = floodFill(x, y);
                                regions.push(region);
                            }
                        }
                    }
                }

                return regions;
            };

            this.updateLayerCanvas = function(layer) {
                // Create a temporary canvas to read the original image
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = this.imagePreview.naturalWidth;
                tempCanvas.height = this.imagePreview.naturalHeight;
                
                // Draw the original image
                tempCtx.drawImage(this.imagePreview, 0, 0);
                
                // Get image data
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const pixels = imageData.data;
                
                // Get source color components
                const sourceRgb = hexToRgb(layer.sourceColor.hex);
                
                // Get target color components
                const targetRgb = hexToRgb(layer.color);
                
                // Get current layer settings
                const toolbar = this.layersContainer.querySelector(`[data-layer-id="${layer.id}"]`);
                if (!toolbar) return;
                
                const direction = toolbar.querySelector('input[type="radio"]:checked').value;
                const pixelCount = parseInt(toolbar.querySelector('.numeric-input').value) || 0;

                // If full mode or pixel count is 0, use original behavior
                if (direction === 'full' || pixelCount === 0) {
                    for (let i = 0; i < pixels.length; i += 4) {
                        if (pixels[i] === sourceRgb.r &&
                            pixels[i + 1] === sourceRgb.g &&
                            pixels[i + 2] === sourceRgb.b) {
                            pixels[i] = targetRgb.r;
                            pixels[i + 1] = targetRgb.g;
                            pixels[i + 2] = targetRgb.b;
                            pixels[i + 3] = 255; // Full opacity
                        } else {
                            pixels[i + 3] = 0; // Transparent
                        }
                    }
                } else {
                    // Find all regions first
                    const regions = this.findBoundingBoxes(pixels, sourceRgb, tempCanvas.width, tempCanvas.height);
                    
                    // Clear all pixels first
                    for (let i = 0; i < pixels.length; i += 4) {
                        pixels[i + 3] = 0; // Make everything transparent initially
                    }

                    // Process each region
                    regions.forEach(region => {
                        const { box, pixelsByRow } = region;

                        if (direction === 'left' || direction === 'right') {
                            // Process by rows for left/right
                            pixelsByRow.forEach((rowPixels, row) => {
                                let pixelsToColor = direction === 'left' ? 
                                    rowPixels.slice(0, pixelCount) : 
                                    rowPixels.slice(-pixelCount);

                                // Color the selected pixels
                                pixelsToColor.forEach(x => {
                                    const i = (row * tempCanvas.width + x) * 4;
                                    pixels[i] = targetRgb.r;
                                    pixels[i + 1] = targetRgb.g;
                                    pixels[i + 2] = targetRgb.b;
                                    pixels[i + 3] = 255;
                                });
                            });
                        } else if (direction === 'top' || direction === 'bottom') {
                            // Organize pixels by column
                            const pixelsByColumn = new Map();
                            
                            // Build columns from our row data
                            pixelsByRow.forEach((rowPixels, row) => {
                                rowPixels.forEach(x => {
                                    if (!pixelsByColumn.has(x)) {
                                        pixelsByColumn.set(x, []);
                                    }
                                    pixelsByColumn.get(x).push(row);
                                });
                            });

                            // Sort rows in each column
                            pixelsByColumn.forEach(columnPixels => columnPixels.sort((a, b) => a - b));

                            // Process each column
                            pixelsByColumn.forEach((columnPixels, x) => {
                                let pixelsToColor;
                                if (direction === 'top') {
                                    pixelsToColor = columnPixels.slice(0, pixelCount);
                                } else { // bottom
                                    pixelsToColor = columnPixels.slice(-pixelCount);
                                }

                                // Color the selected pixels
                                pixelsToColor.forEach(y => {
                                    const i = (y * tempCanvas.width + x) * 4;
                                    pixels[i] = targetRgb.r;
                                    pixels[i + 1] = targetRgb.g;
                                    pixels[i + 2] = targetRgb.b;
                                    pixels[i + 3] = 255;
                                });
                            });
                        }
                    });
                }
                
                // Update the layer's canvas
                const ctx = layer.canvas.getContext('2d');
                ctx.putImageData(imageData, 0, 0);
            };

            this.clearOverlay = function() {
                if (this.overlayCanvas && this.imagePreview.naturalWidth) {
                    const scale = this.zoomLevel / 100;
                    // Set canvas size to match zoomed dimensions
                    this.overlayCanvas.width = this.imagePreview.naturalWidth * scale;
                    this.overlayCanvas.height = this.imagePreview.naturalHeight * scale;
                    this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
                    // Reset transform scale since we're using zoomed canvas dimensions
                    this.overlayCanvas.style.transform = 'none';
                }
            };
            
            this.findAndDrawBoundingBoxes = function() {
                if (!this.selectedColor || !this.imagePreview.naturalWidth) return;

                // Create a canvas to read pixel data
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = this.imagePreview.naturalWidth;
                canvas.height = this.imagePreview.naturalHeight;
                ctx.drawImage(this.imagePreview, 0, 0);

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const pixels = imageData.data;
                
                // Create a visited array for flood fill
                const visited = new Array(canvas.width * canvas.height).fill(false);
                const boundingBoxes = [];

                // Helper function to check if a pixel matches the selected color
                const isMatchingColor = (index) => {
                    const r = pixels[index];
                    const g = pixels[index + 1];
                    const b = pixels[index + 2];
                    const a = pixels[index + 3];
                    return r === this.selectedColor.r && 
                           g === this.selectedColor.g && 
                           b === this.selectedColor.b && 
                           a === this.selectedColor.a;
                };

                // Helper function to get pixel index from coordinates
                const getPixelIndex = (x, y) => (y * canvas.width + x) * 4;

                // Flood fill to find connected components
                const floodFill = (startX, startY) => {
                    const box = { minX: startX, minY: startY, maxX: startX, maxY: startY };
                    const stack = [[startX, startY]];
                    const pixelIdx = getPixelIndex(startX, startY);
                    
                    if (!isMatchingColor(pixelIdx)) return null;
                    
                    visited[startY * canvas.width + startX] = true;

                    while (stack.length > 0) {
                        const [x, y] = stack.pop();
                        
                        // Update bounding box
                        box.minX = Math.min(box.minX, x);
                        box.minY = Math.min(box.minY, y);
                        box.maxX = Math.max(box.maxX, x);
                        box.maxY = Math.max(box.maxY, y);

                        // Check orthogonally adjacent pixels
                        const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                        for (const [dx, dy] of directions) {
                            const newX = x + dx;
                            const newY = y + dy;
                            
                            if (newX >= 0 && newX < canvas.width && 
                                newY >= 0 && newY < canvas.height && 
                                !visited[newY * canvas.width + newX]) {
                                
                                const newPixelIdx = getPixelIndex(newX, newY);
                                if (isMatchingColor(newPixelIdx)) {
                                    stack.push([newX, newY]);
                                    visited[newY * canvas.width + newX] = true;
                                }
                            }
                        }
                    }
                    return box;
                };

                // Find all connected components
                for (let y = 0; y < canvas.height; y++) {
                    for (let x = 0; x < canvas.width; x++) {
                        if (!visited[y * canvas.width + x]) {
                            const box = floodFill(x, y);
                            if (box) boundingBoxes.push(box);
                        }
                    }
                }

                // Clear and update overlay canvas size
                this.clearOverlay();

                // Draw bounding boxes
                const scale = this.zoomLevel / 100;
                this.overlayCtx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                this.overlayCtx.lineWidth = 1;
                
                // Scale the context for drawing
                this.overlayCtx.save();
                this.overlayCtx.scale(scale, scale);
                
                boundingBoxes.forEach(box => {
                    // Draw at original coordinates, letting the context scale handle the zoom
                    this.overlayCtx.strokeRect(
                        box.minX,
                        box.minY,
                        box.maxX - box.minX + 1,
                        box.maxY - box.minY + 1
                    );
                });
                
                this.overlayCtx.restore();
            };

            this.resetLayers = function() {
                // Return all canvases to the pool
                this.colorLayers.forEach(layers => {
                    layers.forEach(layer => {
                        // Clear the canvas before adding to pool
                        const ctx = layer.canvas.getContext('2d');
                        ctx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
                        this.canvasPool.push(layer.canvas);
                    });
                });
                
                // Clear the color layers map
                this.colorLayers.clear();
                
                // Clear the UI
                this.layerRows.innerHTML = '';
                this.layersContainer.style.display = 'none';
                
                // Clear the layers canvas
                if (this.layersCanvas) {
                    this.layersCtx.clearRect(0, 0, this.layersCanvas.width, this.layersCanvas.height);
                }
            };

            this.handleFileSelect = function(event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        this.imagePreview.src = e.target.result;
                        this.imagePreview.style.display = 'block';
                        this.selectedColor = null; // Clear selected color
                        this.resetLayers(); // Reset all layers
                        
                        // Wait for image to load to get dimensions
                        this.imagePreview.onload = () => {
                            this.updateImageInfo();
                            this.updateZoom();
                            this.clearOverlay();
                        };
                    };
                    reader.readAsDataURL(file);
                }
            };
            
            this.updateImageInfo = function() {
                const width = this.imagePreview.naturalWidth;
                const height = this.imagePreview.naturalHeight;
                this.imageInfo.textContent = `Image dimensions: ${width}×${height} pixels`;
                
                // Scan for colors when image is loaded
                this.scanImageColors();
            };
            
            this.scanImageColors = function() {
                // Create a canvas to read the pixel colors
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = this.imagePreview.naturalWidth;
                canvas.height = this.imagePreview.naturalHeight;
                ctx.drawImage(this.imagePreview, 0, 0);
                
                // Get all pixel data
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const pixels = imageData.data;
                
                // Clear previous color map
                this.colorMap.clear();
                
                // Scan all pixels
                for (let i = 0; i < pixels.length; i += 4) {
                    const r = pixels[i];
                    const g = pixels[i + 1];
                    const b = pixels[i + 2];
                    const a = pixels[i + 3];
                    
                    // Skip transparent pixels
                    if (a === 0) continue;
                    
                    const hex = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                    
                    // Count occurrences of each color
                    if (this.colorMap.has(hex)) {
                        this.colorMap.set(hex, {
                            count: this.colorMap.get(hex).count + 1,
                            r, g, b, a
                        });
                    } else {
                        this.colorMap.set(hex, { count: 1, r, g, b, a });
                    }
                }
                
                this.displayColors();
                // Ensure bounding boxes are drawn after colors are loaded
                if (this.selectedColor) {
                    requestAnimationFrame(() => this.findAndDrawBoundingBoxes());
                }
            };
            
            this.displayColors = function() {
                // Clear previous options
                this.colorOptions.innerHTML = '';
                
                // Sort colors by count (most frequent first)
                const sortedColors = Array.from(this.colorMap.entries())
                    .sort((a, b) => b[1].count - a[1].count);
                
                // Create radio buttons for each color
                sortedColors.forEach(([hex, data], index) => {
                    const colorDiv = document.createElement('div');
                    colorDiv.className = 'color-option';
                    
                    const input = document.createElement('input');
                    input.type = 'radio';
                    input.name = 'color';
                    input.id = `color-${index}`;
                    input.value = hex;
                    input.addEventListener('change', () => {
                        this.selectedColor = { hex, ...data };
                        this.findAndDrawBoundingBoxes();
                        this.updateLayerDisplay(); // Update layer display when color changes
                        this.addLayerBtn.disabled = false;
                    });
                    
                    const preview = document.createElement('div');
                    preview.className = 'color-preview';
                    preview.style.backgroundColor = hex;
                    
                    const label = document.createElement('label');
                    label.htmlFor = `color-${index}`;
                    label.className = 'color-info';
                    
                    const hexSpan = document.createElement('span');
                    hexSpan.className = 'color-hex';
                    hexSpan.textContent = hex.toUpperCase();
                    
                    const rgbSpan = document.createElement('span');
                    rgbSpan.className = 'color-rgb';
                    rgbSpan.textContent = `RGB(${data.r}, ${data.g}, ${data.b})`;
                    
                    const countSpan = document.createElement('span');
                    countSpan.className = 'color-count';
                    countSpan.textContent = `${data.count} pixels`;
                    
                    label.appendChild(preview);
                    label.appendChild(hexSpan);
                    label.appendChild(rgbSpan);
                    label.appendChild(countSpan);
                    
                    colorDiv.appendChild(input);
                    colorDiv.appendChild(label);
                    
                    this.colorOptions.appendChild(colorDiv);
                    
                    // Auto-select the first color
                    if (index === 0) {
                        input.checked = true;
                        this.selectedColor = { hex, ...data };
                        this.addLayerBtn.disabled = false;
                        // Ensure bounding boxes are drawn for the auto-selected color
                        requestAnimationFrame(() => this.findAndDrawBoundingBoxes());
                    }
                });
                
                this.colorsContainer.style.display = 'block';
                this.layersContainer.style.display = 'none'; // Reset layers container
                this.clearOverlay(); // Clear any existing bounding boxes
            };
            
            this.zoomIn = function() {
                const currentIndex = this.zoomLevels.indexOf(this.zoomLevel);
                if (currentIndex < this.zoomLevels.length - 1) {
                    this.zoomLevel = this.zoomLevels[currentIndex + 1];
                    this.updateZoom();
                }
            };
            
            this.zoomOut = function() {
                const currentIndex = this.zoomLevels.indexOf(this.zoomLevel);
                if (currentIndex > 0) {
                    this.zoomLevel = this.zoomLevels[currentIndex - 1];
                    this.updateZoom();
                }
            };
            
            this.updateLayerColor = function(layerId, sourceColorHex, newColor) {
                const layers = this.colorLayers.get(sourceColorHex) || [];
                const layer = layers.find(l => l.id === layerId);
                if (!layer) return;

                layer.color = newColor;
                this.updateLayerCanvas(layer);
                this.updateLayerDisplay();

                // Update color picker and hex input to match
                const toolbar = this.layersContainer.querySelector(`[data-layer-id="${layerId}"][data-color-hex="${sourceColorHex}"]`);
                if (toolbar) {
                    const colorInput = toolbar.querySelector('.layer-color-input');
                    const hexInput = toolbar.querySelector('.hex-color-input');
                    if (colorInput) colorInput.value = newColor;
                    if (hexInput) hexInput.value = newColor.toUpperCase();
                }
            };

            this.updateLayerDisplay = function() {
                if (!this.layersCanvas || !this.imagePreview.naturalWidth) return;

                // Set canvas to original image size
                this.layersCanvas.width = this.imagePreview.naturalWidth;
                this.layersCanvas.height = this.imagePreview.naturalHeight;
                this.layersCtx.clearRect(0, 0, this.layersCanvas.width, this.layersCanvas.height);

                // Display all layers from all colors at original size
                this.colorLayers.forEach(layers => {
                    layers.forEach(layer => {
                        this.layersCtx.drawImage(layer.canvas, 0, 0);
                    });
                });

                // Show/hide layer rows based on selected color
                const allLayerRows = this.layerRows.querySelectorAll('.layer-row');
                allLayerRows.forEach(row => {
                    if (this.selectedColor && row.dataset.colorHex === this.selectedColor.hex) {
                        row.style.display = '';
                    } else {
                        row.style.display = 'none';
                    }
                });

                // Show/hide layers container based on whether there are layers for this color
                if (this.selectedColor && this.colorLayers.has(this.selectedColor.hex) && 
                    this.colorLayers.get(this.selectedColor.hex).length > 0) {
                    this.layersContainer.style.display = 'block';
                } else {
                    this.layersContainer.style.display = 'none';
                }
            };

            this.updateZoom = function() {
                const scale = this.zoomLevel / 100;
                this.zoomDisplay.textContent = `${this.zoomLevel}%`;

                // Update image and container sizes
                if (this.imagePreview.naturalWidth && this.imagePreview.naturalHeight) {
                    const scaledWidth = this.imagePreview.naturalWidth * scale;
                    const scaledHeight = this.imagePreview.naturalHeight * scale;
                    
                    const container = document.querySelector('.image-preview-container');
                    container.style.width = `${Math.max(scaledWidth, window.innerWidth - 100)}px`;
                    const scrollbarHeight = scaledWidth > (window.innerWidth - 100) ? 17 : 0;
                    container.style.height = `${scaledHeight + scrollbarHeight}px`;
                    
                    // Apply transform scaling to image and layers canvas
                    const transformStyle = `scale(${scale})`;
                    const elements = [this.imagePreview, this.layersCanvas];
                    
                    elements.forEach(element => {
                        if (element) {
                            element.style.transformOrigin = 'top left';
                            element.style.transform = transformStyle;
                        }
                    });
                    
                    if (scaledWidth < (window.innerWidth - 100)) {
                        this.imagePreview.style.display = 'block';
                        this.imagePreview.style.margin = '0';
                    } else {
                        this.imagePreview.style.margin = '0';
                    }

                    // Update canvases if there's content
                    if (this.selectedColor) {
                        this.findAndDrawBoundingBoxes();
                        // Only update layers if we have any for the selected color
                        if (this.colorLayers.has(this.selectedColor.hex)) {
                            this.updateLayerDisplay();
                        }
                    }
                }
            };
            
            // Initialize
            this.initializeElements();
            this.bindEvents();
        }

        let textureTool;
        document.addEventListener('DOMContentLoaded', () => {
            textureTool = new TextureTool();
        });
    </script>
</body>

</html>