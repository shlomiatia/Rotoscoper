<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprite Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f0f0;
        }

        .container {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .back-btn {
            background-color: #6c757d;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 3px;
            cursor: pointer;
            text-decoration: none;
            font-size: 14px;
        }

        .back-btn:hover {
            background-color: #5a6268;
        }

        .animation-container {
            text-align: center;
            margin-bottom: 20px;
            background-color: #f8f8f8;
            padding: 20px;
            border-radius: 5px;
            position: relative;
        }

        .frame-preview-container {
            position: relative;
            display: inline-block;
            border: 2px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
        }

        #frame-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            width: auto;
            height: auto;
        }

        .frame-image {
            display: none;
        }

        .frame-image.active {
            display: block;
        }

        .sprite-canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .sprite-canvas {
            position: absolute;
            top: 0px;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .animation-selector {
            margin-bottom: 10px;
        }

        .animation-selector select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }

        .control-group {
            background-color: #f8f8f8;
            padding: 15px;
            border-radius: 5px;
        }

        .control-group h3 {
            margin: 0 0 10px 0;
            color: #333;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .input-group label {
            min-width: 80px;
            font-weight: bold;
        }

        input[type="range"] {
            flex: 1;
        }

        input[type="number"] {
            width: 80px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }

        .play-pause-btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            width: 100%;
        }

        .play-pause-btn:hover {
            background-color: #0056b3;
        }

        .sprite-controls {
            background-color: #f8f8f8;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .sprite-controls h3 {
            margin: 0 0 15px 0;
            color: #333;
        }

        .color-mapping-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            margin-top: 15px;
            background-color: #ffffff;
        }

        .color-mapping-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 8px;
            border: 1px solid #eee;
            border-radius: 3px;
            background-color: #f9f9f9;
        }

        .color-mapping-item:last-child {
            margin-bottom: 0;
        }

        .source-color-preview {
            width: 30px;
            height: 30px;
            border: 1px solid #ccc;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .color-mapping-info {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .color-hex {
            font-family: monospace;
            font-size: 12px;
            font-weight: bold;
            color: #333;
        }

        .color-count {
            font-size: 11px;
            color: #666;
        }

        .target-color-picker {
            width: 40px;
            height: 30px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            flex-shrink: 0;
        }

        .color-mapping-controls {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
            background-color: #ffffff;
        }

        .color-mapping-controls h4 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 14px;
        }

        .sprite-button {
            background-color: #6f42c1;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .sprite-button:hover {
            background-color: #5a2d91;
        }

        .sprite-button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }

        .opacity-input {
            width: 60px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }

        .info {
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .info-item:last-child {
            margin-bottom: 0;
        }

        .info-label {
            font-weight: bold;
        }

        .sort-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }

        .sort-controls label {
            font-weight: bold;
            min-width: auto;
        }

        .sort-select {
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
            background-color: white;
        }

        .magic-wand-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            align-items: center;
            padding: 15px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }

        .magic-wand-controls label {
            font-weight: bold;
            min-width: auto;
        }

        .tolerance-input {
            width: 60px;
            padding: 4px 6px;
            border: 1px solid #ddd;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
        }

        .tolerance-range {
            font-size: 12px;
            color: #666;
            font-weight: bold;
            min-width: 30px;
            text-align: center;
            display: inline-block;
        }

        .tolerance-btn {
            font-size: 12px;
            padding: 6px 10px;
            margin-left: 5px;
        }

        .hex-color-input {
            width: 70px;
            padding: 4px 6px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
            text-transform: uppercase;
        }

        .wand-color-input {
            width: 30px;
            height: 28px;
            border: 1px solid #ddd;
            border-radius: 3px;
            cursor: pointer;
            padding: 0;
        }

        .layer-container {
            margin-bottom: 15px;
        }

        .layer-toolbar {
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 5px;
            margin-bottom: 10px;
            background-color: #f9f9f9;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .layer-toolbar.active {
            border-color: #007bff;
            background-color: #e3f2fd;
            box-shadow: 0 2px 8px rgba(0, 123, 255, 0.2);
        }

        .layer-toolbar:hover {
            border-color: #aaa;
        }

        .layer-header {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .layer-name-input {
            flex: 1;
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-weight: bold;
            font-size: 14px;
            min-width: 100px;
        }

        .layer-delete-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }

        .layer-delete-btn:hover {
            background-color: #c82333;
        }

        .add-layer-btn {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
            font-size: 14px;
        }

        .add-layer-btn:hover {
            background-color: #218838;
        }

        .frame-preview-container {
            position: relative;
            display: inline-block;
            border: 2px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
            cursor: crosshair;
        }

        .click-indicator {
            position: absolute;
            width: 3px;
            height: 3px;
            background-color: #ff0000;
            border: 1px solid #fff;
            border-radius: 50%;
            pointer-events: none;
            z-index: 20;
            transform: translate(-50%, -50%);
            display: none;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>Sprite Tool</h1>
            <a href="index.html" class="back-btn">← Back to Tools</a>
        </div>

        <div class="control-group">
            <h3>Playback Controls</h3>
            <button class="play-pause-btn" id="play-pause-btn">Play</button>

            <div class="input-group">
                <label>Frame:</label>
                <input type="range" id="frame-slider" min="0" max="149" value="0">
                <input type="number" id="frame-input" min="0" max="149" value="0">
            </div>
        </div>

        <div class="animation-container">
            <div class="frame-preview-container" id="frame-preview-container">
                <div id="frame-container"></div>
                <div class="sprite-canvas-container" id="sprite-canvas-container"></div>
                <div class="click-indicator" id="click-indicator"></div>
            </div>
        </div>

        <div class="sprite-controls">
            <div id="layers-container" class="layer-container">
                <!-- Layers will be dynamically created here -->
            </div>
            <button class="add-layer-btn" id="add-layer-btn">Add Layer</button>
        </div>


        <div class="control-group">
            <h3>Timing Settings</h3>
            <div class="input-group">
                <label>Delay (ms):</label>
                <input type="range" id="delay-slider" min="10" max="1000" value="30">
                <input type="number" id="delay-input" min="10" max="1000" value="30">
            </div>

            <div class="input-group">
                <label>FPS:</label>
                <span id="fps-display">33.3</span>
            </div>
        </div>

        <div class="control-group">
            <h3>Animation Settings</h3>

            <div class="input-group">
                <label>Animation:</label>
                <select id="animation-select">
                    <option value="Walk">Walk</option>
                </select>
            </div>

            <div class="input-group">
                <label>Sprite Opacity:</label>
                <input type="number" id="sprite-opacity-input" class="opacity-input" value="70" min="0" max="100"
                    step="1">
                <span>%</span>
            </div>

            <div class="input-group">
                <label>
                    <input type="checkbox" id="show-frames-checkbox" checked>
                    Show Frames
                </label>
            </div>
        </div>
    </div>

    <script>
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;

            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }

            return {
                h: Math.round(h * 360),
                s: Math.round(s * 100),
                l: Math.round(l * 100)
            };
        }

        function hexToHsl(hex) {
            const rgb = hexToRgb(hex);
            return rgb ? rgbToHsl(rgb.r, rgb.g, rgb.b) : null;
        }

        class SpriteTool {
            constructor() {
                this.currentFrame = 0;
                this.totalFrames = 150;
                this.delay = 30;
                this.isPlaying = false;
                this.animationId = null;
                this.currentAnimation = 'Walk';
                this.animations = [];
                this.animationData = {};

                this.frameWidth = 0;
                this.frameHeight = 0;
                this.frameElements = {};
                this.currentFrameElement = null;

                this.spriteCanvases = {};
                this.spriteData = {};
                this.currentSpriteCanvas = null;
                this.showFrames = true;
                this.spriteOpacity = 70;

                // Layer system properties
                this.layers = []; // Array of layer objects
                this.activeLayerId = null;
                this.nextLayerId = 1;
                this.layerMasks = {}; // Store masks per animation per frame per layer: {animationName: {frameIndex: {layerId: mask}}}
                this.layerCanvases = {}; // Store canvases per animation per frame per layer

                this.initializeElements();
                this.bindEvents();
                this.loadAvailableAnimations();
                this.updateDisplays();

                setTimeout(() => {
                    this.createFrameElements();
                    this.initializeLayerSystem();
                }, 100);
            }

            initializeElements() {
                this.frameContainer = document.getElementById('frame-container');
                this.playPauseBtn = document.getElementById('play-pause-btn');
                this.frameSlider = document.getElementById('frame-slider');
                this.frameInput = document.getElementById('frame-input');
                this.delaySlider = document.getElementById('delay-slider');
                this.delayInput = document.getElementById('delay-input');
                this.fpsDisplay = document.getElementById('fps-display');
                this.animationSelect = document.getElementById('animation-select');
                this.spriteOpacityInput = document.getElementById('sprite-opacity-input');
                this.showFramesCheckbox = document.getElementById('show-frames-checkbox');
                this.spriteCanvasContainer = document.getElementById('sprite-canvas-container');
                this.framePreviewContainer = document.getElementById('frame-preview-container');
                this.clickIndicator = document.getElementById('click-indicator');
                this.layersContainer = document.getElementById('layers-container');
                this.addLayerBtn = document.getElementById('add-layer-btn');
            }

            initializeLayerSystem() {
                // Create the first default layer
                this.addLayer('#ff0000', 'Layer 1');
            }

            addLayer(color = '#ff0000', name = null) {
                const layerId = this.nextLayerId++;
                const layerName = name || `Layer ${layerId}`;

                const layer = {
                    id: layerId,
                    name: layerName,
                    color: color,
                    tolerance: 128,
                    frameSettings: {} // Store per-frame settings for this layer
                };

                this.layers.push(layer);
                this.createLayerToolbar(layer);
                this.setActiveLayer(layerId);

                return layer;
            }

            createLayerToolbar(layer) {
                const toolbar = document.createElement('div');
                toolbar.className = 'layer-toolbar';
                toolbar.dataset.layerId = layer.id;

                toolbar.innerHTML = `
                    <div class="layer-header">
                        <input type="text" class="layer-name-input" value="${layer.name}"
                               onchange="spriteTool.updateLayerName(${layer.id}, this.value)"
                               onblur="spriteTool.updateLayerName(${layer.id}, this.value)">
                        <span class="tolerance-range min-tolerance-display">0</span>
                        <input type="number" class="tolerance-input" value="${layer.tolerance}" min="0" max="255" step="1"
                               onchange="spriteTool.updateLayerTolerance(${layer.id}, this.value)"
                               onkeydown="spriteTool.handleToleranceKeyDown(event)">
                        <span class="tolerance-range max-tolerance-display">255</span>
                        <input type="text" class="hex-color-input" value="${layer.color}" placeholder="#ff0000"
                               onchange="spriteTool.updateLayerColorFromHex(${layer.id}, this.value)"
                               onblur="spriteTool.updateLayerColorFromHex(${layer.id}, this.value)">
                        <input type="color" class="wand-color-input" value="${layer.color}"
                               onchange="spriteTool.updateLayerColor(${layer.id}, this.value)">
                        <button class="layer-delete-btn" onclick="spriteTool.deleteLayer(${layer.id})" ${this.layers.length === 1 ? 'disabled' : ''}>Delete</button>
                    </div>
                `;

                // Add click event for layer selection
                toolbar.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('layer-delete-btn') &&
                        !e.target.classList.contains('tolerance-input') &&
                        !e.target.classList.contains('wand-color-input') &&
                        !e.target.classList.contains('hex-color-input') &&
                        !e.target.classList.contains('layer-name-input')) {
                        this.setActiveLayer(layer.id);
                    }
                });

                // Insert at the beginning to stack layers
                this.layersContainer.insertBefore(toolbar, this.layersContainer.firstChild);
            }

            setActiveLayer(layerId) {
                this.activeLayerId = layerId;

                // Update visual state
                const toolbars = this.layersContainer.querySelectorAll('.layer-toolbar');
                toolbars.forEach(toolbar => {
                    if (parseInt(toolbar.dataset.layerId) === layerId) {
                        toolbar.classList.add('active');
                    } else {
                        toolbar.classList.remove('active');
                    }
                });

                // Load settings for current frame and layer
                this.loadCurrentFrameSettings();
            }

            deleteLayer(layerId) {
                if (this.layers.length <= 1) return; // Don't delete the last layer

                this.layers = this.layers.filter(layer => layer.id !== layerId);

                // Remove toolbar
                const toolbar = this.layersContainer.querySelector(`[data-layer-id="${layerId}"]`);
                if (toolbar) {
                    toolbar.remove();
                }

                // Clear layer data
                this.clearLayerData(layerId);

                // Set new active layer if current was deleted
                if (this.activeLayerId === layerId) {
                    this.setActiveLayer(this.layers[0].id);
                }

                // Update delete button states
                this.updateDeleteButtonStates();

                // Regenerate sprites
                this.generateAllSprites();
            }

            clearLayerData(layerId) {
                // Clear masks and canvases for this layer
                Object.keys(this.layerMasks).forEach(animationName => {
                    Object.keys(this.layerMasks[animationName]).forEach(frameIndex => {
                        delete this.layerMasks[animationName][frameIndex][layerId];
                    });
                });

                Object.keys(this.layerCanvases).forEach(animationName => {
                    Object.keys(this.layerCanvases[animationName]).forEach(frameIndex => {
                        delete this.layerCanvases[animationName][frameIndex][layerId];
                    });
                });
            }

            updateDeleteButtonStates() {
                const deleteButtons = this.layersContainer.querySelectorAll('.layer-delete-btn');
                deleteButtons.forEach(btn => {
                    btn.disabled = this.layers.length <= 1;
                });
            }

            updateLayerTolerance(layerId, tolerance) {
                const layer = this.layers.find(l => l.id === layerId);
                if (layer) {
                    layer.tolerance = parseInt(tolerance);
                    if (layerId === this.activeLayerId) {
                        this.reapplyCurrentFrame();
                    }
                }
            }

            updateLayerColor(layerId, color) {
                const layer = this.layers.find(l => l.id === layerId);
                if (layer) {
                    layer.color = color;
                    this.updateAllSprites();

                    // Sync the hex input with the color picker
                    const toolbar = this.layersContainer.querySelector(`[data-layer-id="${layerId}"]`);
                    const hexInput = toolbar?.querySelector('.hex-color-input');
                    if (hexInput) {
                        hexInput.value = color.toUpperCase();
                    }
                }
            }

            updateLayerColorFromHex(layerId, hexValue) {
                // Validate and normalize hex color
                let normalizedHex = hexValue.trim();

                // Add # if missing
                if (!normalizedHex.startsWith('#')) {
                    normalizedHex = '#' + normalizedHex;
                }

                // Validate hex format
                const hexRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
                if (!hexRegex.test(normalizedHex)) {
                    // Invalid hex, revert to current color
                    const layer = this.layers.find(l => l.id === layerId);
                    const toolbar = this.layersContainer.querySelector(`[data-layer-id="${layerId}"]`);
                    const hexInput = toolbar?.querySelector('.hex-color-input');
                    if (layer && hexInput) {
                        hexInput.value = layer.color.toUpperCase();
                    }
                    return;
                }

                // Convert 3-digit hex to 6-digit
                if (normalizedHex.length === 4) {
                    normalizedHex = '#' + normalizedHex[1] + normalizedHex[1] +
                                   normalizedHex[2] + normalizedHex[2] +
                                   normalizedHex[3] + normalizedHex[3];
                }

                const layer = this.layers.find(l => l.id === layerId);
                if (layer) {
                    layer.color = normalizedHex.toUpperCase();
                    this.updateAllSprites();

                    // Sync the color picker with the hex input
                    const toolbar = this.layersContainer.querySelector(`[data-layer-id="${layerId}"]`);
                    const colorInput = toolbar?.querySelector('.wand-color-input');
                    const hexInput = toolbar?.querySelector('.hex-color-input');

                    if (colorInput) {
                        colorInput.value = normalizedHex.toLowerCase(); // Color input expects lowercase
                    }
                    if (hexInput) {
                        hexInput.value = normalizedHex.toUpperCase(); // Display uppercase
                    }
                }
            }

            updateLayerName(layerId, name) {
                const layer = this.layers.find(l => l.id === layerId);
                if (layer) {
                    layer.name = name.trim() || `Layer ${layerId}`;
                    // Update the input value in case we had to fallback to default name
                    const toolbar = this.layersContainer.querySelector(`[data-layer-id="${layerId}"]`);
                    const nameInput = toolbar?.querySelector('.layer-name-input');
                    if (nameInput) {
                        nameInput.value = layer.name;
                    }
                }
            }

            getActiveLayer() {
                return this.layers.find(layer => layer.id === this.activeLayerId);
            }

            bindEvents() {
                this.playPauseBtn.addEventListener('click', () => this.togglePlayPause());

                this.frameSlider.addEventListener('input', (e) => {
                    this.setFrame(parseInt(e.target.value));
                });

                this.frameInput.addEventListener('change', (e) => {
                    this.setFrame(parseInt(e.target.value));
                });

                this.delaySlider.addEventListener('input', (e) => {
                    this.setDelay(parseInt(e.target.value));
                });

                this.delayInput.addEventListener('change', (e) => {
                    this.setDelay(parseInt(e.target.value));
                });

                this.animationSelect.addEventListener('change', (e) => {
                    this.switchAnimation(e.target.value);
                });

                // Add layer button event
                this.addLayerBtn.addEventListener('click', () => {
                    this.addLayer();
                });

                this.showFramesCheckbox.addEventListener('change', (e) => {
                    this.showFrames = e.target.checked;
                    this.updateVisibility();
                });

                this.spriteOpacityInput.addEventListener('change', (e) => {
                    this.spriteOpacity = parseInt(e.target.value) || 0;
                    this.updateSpriteOpacity();
                });

                // Frame click event for magic wand tool
                this.framePreviewContainer.addEventListener('click', (e) => {
                    this.handleFrameClick(e);
                });
            }

            setFrame(frame) {
                this.currentFrame = Math.max(0, Math.min(frame, this.totalFrames - 1));
                this.loadCurrentFrameSettings();
                this.updateFrame();
                this.updateDisplays();
            }

            setDelay(delay) {
                this.delay = Math.max(10, Math.min(delay, 1000));
                this.delaySlider.value = this.delay;
                this.delayInput.value = this.delay;
                this.updateDisplays();

                if (this.isPlaying) {
                    this.stopAnimation();
                    this.startAnimation();
                }
            }

            updateFrame() {
                if (this.currentFrameElement) {
                    this.currentFrameElement.classList.remove('active');
                }

                if (this.currentSpriteCanvas) {
                    this.currentSpriteCanvas.style.display = 'none';
                }

                if (this.frameElements[this.currentAnimation] &&
                    this.frameElements[this.currentAnimation][this.currentFrame]) {
                    this.currentFrameElement = this.frameElements[this.currentAnimation][this.currentFrame];
                    if (this.showFrames) {
                        this.currentFrameElement.classList.add('active');
                    }
                }

                if (this.spriteCanvases[this.currentAnimation] &&
                    this.spriteCanvases[this.currentAnimation][this.currentFrame]) {
                    this.currentSpriteCanvas = this.spriteCanvases[this.currentAnimation][this.currentFrame];
                    this.currentSpriteCanvas.style.display = 'block';
                    this.currentSpriteCanvas.style.opacity = this.spriteOpacity / 100;
                }
            }

            createFrameElements() {
                this.frameContainer.innerHTML = '';
                this.currentFrameElement = null;

                if (!this.frameElements[this.currentAnimation]) {
                    this.frameElements[this.currentAnimation] = {};
                }

                const frameFiles = this.animationData[this.currentAnimation]?.frames || [];

                for (let frame = 0; frame < this.totalFrames; frame++) {
                    let img = this.frameElements[this.currentAnimation][frame];

                    if (!img) {
                        let frameSrc;
                        if (frameFiles.length > frame) {
                            frameSrc = `Source/${this.currentAnimation}/${frameFiles[frame]}`;
                        } else {
                            // Fallback to old pattern for backwards compatibility
                            const frameNumber = String(frame).padStart(3, '0');
                            frameSrc = `Source/${this.currentAnimation}/frame_${frameNumber}_delay-0.03s.gif`;
                        }

                        img = document.createElement('img');
                        img.className = 'frame-image';
                        img.src = frameSrc;
                        img.alt = `Frame ${frame}`;

                        if (frame === 0) {
                            img.onload = () => {
                                this.frameWidth = img.naturalWidth;
                                this.frameHeight = img.naturalHeight;
                                this.setContainerDimensions();
                            };
                        } else {
                            img.onload = () => {
                                if (!this.frameWidth || !this.frameHeight) {
                                    this.frameWidth = img.naturalWidth;
                                    this.frameHeight = img.naturalHeight;
                                    this.setContainerDimensions();
                                }
                            };
                        }

                        this.frameElements[this.currentAnimation][frame] = img;
                    }

                    // Always append the frame element to the container, whether it's new or existing
                    this.frameContainer.appendChild(img);
                }

                this.updateFrame();
            }

            nextFrame() {
                this.currentFrame++;
                if (this.currentFrame >= this.totalFrames) {
                    this.currentFrame = 0;
                }
                this.updateFrame();
                this.updateDisplays();
            }

            togglePlayPause() {
                if (this.isPlaying) {
                    this.stopAnimation();
                } else {
                    this.startAnimation();
                }
            }

            startAnimation() {
                this.isPlaying = true;
                this.playPauseBtn.textContent = 'Pause';

                const animate = () => {
                    if (this.isPlaying) {
                        this.nextFrame();
                        this.animationId = setTimeout(animate, this.delay);
                    }
                };

                this.animationId = setTimeout(animate, this.delay);
            }

            stopAnimation() {
                this.isPlaying = false;
                this.playPauseBtn.textContent = 'Play';
                if (this.animationId) {
                    clearTimeout(this.animationId);
                    this.animationId = null;
                }
            }

            updateDisplays() {
                this.frameSlider.value = this.currentFrame;
                this.frameInput.value = this.currentFrame;

                const fps = (1000 / this.delay).toFixed(1);
                this.fpsDisplay.textContent = fps;


            }

            async loadAvailableAnimations() {
                try {
                    const response = await fetch('/api/animations');
                    const data = await response.json();

                    if (data.success) {
                        this.animations = data.animations.map(anim => anim.name);
                        this.animationData = {};

                        data.animations.forEach(anim => {
                            this.animationData[anim.name] = {
                                frameCount: anim.frameCount,
                                frames: anim.frames || []
                            };
                        });

                        if (this.animations.includes('Walk')) {
                            this.currentAnimation = 'Walk';
                        } else if (this.animations.length > 0) {
                            this.currentAnimation = this.animations[0];
                        }

                        if (this.currentAnimation && this.animationData[this.currentAnimation]) {
                            this.totalFrames = this.animationData[this.currentAnimation].frameCount;
                        }

                        this.updateAnimationSelect();
                    } else {
                        this.animations = ['Walk'];
                        this.animationData = { 'Walk': { frameCount: 150, frames: [] } };
                        this.currentAnimation = 'Walk';
                        this.totalFrames = 150;
                        this.updateAnimationSelect();
                    }
                } catch (error) {
                    this.animations = ['Walk'];
                    this.animationData = { 'Walk': { frameCount: 150, frames: [] } };
                    this.currentAnimation = 'Walk';
                    this.totalFrames = 150;
                    this.updateAnimationSelect();
                }
            }

            updateAnimationSelect() {
                this.animationSelect.innerHTML = '';
                this.animations.forEach(animation => {
                    const option = document.createElement('option');
                    option.value = animation;
                    option.textContent = animation;
                    if (animation === this.currentAnimation) {
                        option.selected = true;
                    }
                    this.animationSelect.appendChild(option);
                });
            }

            handleFrameClick(e) {
                if (!this.activeLayerId) return;

                const rect = this.framePreviewContainer.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Get the actual image element position
                if (this.currentFrameElement) {
                    const imgRect = this.currentFrameElement.getBoundingClientRect();
                    const containerRect = this.framePreviewContainer.getBoundingClientRect();

                    const imgX = e.clientX - imgRect.left;
                    const imgY = e.clientY - imgRect.top;

                    // Check if click is within the image bounds
                    if (imgX >= 0 && imgX < imgRect.width && imgY >= 0 && imgY < imgRect.height) {
                        // Convert screen coordinates to image coordinates
                        const scaleX = this.frameWidth / imgRect.width;
                        const scaleY = this.frameHeight / imgRect.height;

                        const imageX = Math.floor(imgX * scaleX);
                        const imageY = Math.floor(imgY * scaleY);

                        const activeLayer = this.getActiveLayer();
                        if (activeLayer) {
                            // Reset tolerance to default values when clicking on frame
                            activeLayer.tolerance = 128;

                            // Store settings for current frame and layer with reset tolerance
                            this.saveCurrentFrameSettings(imageX, imageY, 128, 0, 255);

                            // Update UI to show reset tolerance values
                            const activeToolbar = this.layersContainer.querySelector(`[data-layer-id="${this.activeLayerId}"]`);
                            if (activeToolbar) {
                                const toleranceInput = activeToolbar.querySelector('.tolerance-input');
                                const minDisplay = activeToolbar.querySelector('.min-tolerance-display');
                                const maxDisplay = activeToolbar.querySelector('.max-tolerance-display');

                                if (toleranceInput) toleranceInput.value = 128;
                                if (minDisplay) minDisplay.textContent = '0';
                                if (maxDisplay) maxDisplay.textContent = '255';
                            }

                            // Show click indicator
                            this.clickIndicator.style.left = x + 'px';
                            this.clickIndicator.style.top = y + 'px';
                            this.clickIndicator.style.display = 'block';

                            this.performMagicWandCurrentFrame(imageX, imageY);

                            // Focus on the tolerance input for active layer
                            const toleranceInput = activeToolbar?.querySelector('.tolerance-input');
                            if (toleranceInput) {
                                toleranceInput.focus();
                            }
                        }
                    }
                }
            }

            loadCurrentFrameSettings() {
                const activeLayer = this.getActiveLayer();
                if (!activeLayer) return;

                // Initialize layer frame settings if needed
                if (!activeLayer.frameSettings[this.currentAnimation]) {
                    activeLayer.frameSettings[this.currentAnimation] = {};
                }

                const frameSettings = activeLayer.frameSettings[this.currentAnimation][this.currentFrame];
                const activeToolbar = this.layersContainer.querySelector(`[data-layer-id="${this.activeLayerId}"]`);

                if (frameSettings && activeToolbar) {
                    const toleranceInput = activeToolbar.querySelector('.tolerance-input');
                    const minToleranceDisplay = activeToolbar.querySelector('.min-tolerance-display');
                    const maxToleranceDisplay = activeToolbar.querySelector('.max-tolerance-display');

                    if (toleranceInput) toleranceInput.value = frameSettings.tolerance;
                    if (minToleranceDisplay) minToleranceDisplay.textContent = frameSettings.minTolerance || 0;
                    if (maxToleranceDisplay) maxToleranceDisplay.textContent = frameSettings.maxTolerance || 255;

                    // Update click indicator position if there's a saved click
                    if (frameSettings.clickX >= 0 && frameSettings.clickY >= 0) {
                        this.updateClickIndicatorPosition(frameSettings.clickX, frameSettings.clickY);
                    } else {
                        this.clickIndicator.style.display = 'none';
                    }
                } else {
                    // Reset to defaults if no settings for this frame
                    this.clickIndicator.style.display = 'none';
                    if (activeToolbar) {
                        const minToleranceDisplay = activeToolbar.querySelector('.min-tolerance-display');
                        const maxToleranceDisplay = activeToolbar.querySelector('.max-tolerance-display');
                        if (minToleranceDisplay) minToleranceDisplay.textContent = '0';
                        if (maxToleranceDisplay) maxToleranceDisplay.textContent = '255';
                    }
                }
            }

            saveCurrentFrameSettings(clickX, clickY, tolerance, minTolerance = 0, maxTolerance = 255) {
                const activeLayer = this.getActiveLayer();
                if (!activeLayer) return;

                if (!activeLayer.frameSettings[this.currentAnimation]) {
                    activeLayer.frameSettings[this.currentAnimation] = {};
                }

                activeLayer.frameSettings[this.currentAnimation][this.currentFrame] = {
                    clickX: clickX,
                    clickY: clickY,
                    tolerance: tolerance,
                    minTolerance: minTolerance,
                    maxTolerance: maxTolerance
                };
            }

            initializeFrameSettings() {
                // Initialize all frames with default tolerance of 128
                if (!this.frameSettings[this.currentAnimation]) {
                    this.frameSettings[this.currentAnimation] = {};
                }

                for (let frameIndex = 0; frameIndex < this.totalFrames; frameIndex++) {
                    if (!this.frameSettings[this.currentAnimation][frameIndex]) {
                        this.frameSettings[this.currentAnimation][frameIndex] = {
                            clickX: -1,
                            clickY: -1,
                            tolerance: 128,
                            minTolerance: 0,
                            maxTolerance: 255
                        };
                    }
                }
            }

            adjustToleranceLess(layerId) {
                const layer = this.layers.find(l => l.id === layerId);
                if (!layer) return;

                // Initialize layer frame settings if needed
                if (!layer.frameSettings) {
                    layer.frameSettings = {};
                }
                if (!layer.frameSettings[this.currentAnimation]) {
                    layer.frameSettings[this.currentAnimation] = {};
                }

                const settings = layer.frameSettings[this.currentAnimation][this.currentFrame];
                if (!settings || settings.clickX < 0) {
                    alert('Please click on the frame first to set a starting point');
                    return;
                }

                // Binary search: current tolerance becomes max, new tolerance is midpoint
                settings.maxTolerance = layer.tolerance;
                layer.tolerance = Math.floor((settings.minTolerance + settings.maxTolerance) / 2);
                settings.tolerance = layer.tolerance;

                // Update UI for this layer
                const toolbar = this.layersContainer.querySelector(`[data-layer-id="${layerId}"]`);
                if (toolbar) {
                    const toleranceInput = toolbar.querySelector('.tolerance-input');
                    const minDisplay = toolbar.querySelector('.min-tolerance-display');
                    const maxDisplay = toolbar.querySelector('.max-tolerance-display');

                    if (toleranceInput) toleranceInput.value = layer.tolerance;
                    if (minDisplay) minDisplay.textContent = settings.minTolerance;
                    if (maxDisplay) maxDisplay.textContent = settings.maxTolerance;
                }

                // Reapply magic wand with new tolerance for current frame
                if (layerId === this.activeLayerId) {
                    this.performMagicWandCurrentFrame(settings.clickX, settings.clickY);
                }
            }

            adjustToleranceMore(layerId) {
                const layer = this.layers.find(l => l.id === layerId);
                if (!layer) return;

                // Initialize layer frame settings if needed
                if (!layer.frameSettings) {
                    layer.frameSettings = {};
                }
                if (!layer.frameSettings[this.currentAnimation]) {
                    layer.frameSettings[this.currentAnimation] = {};
                }

                const settings = layer.frameSettings[this.currentAnimation][this.currentFrame];
                if (!settings || settings.clickX < 0) {
                    alert('Please click on the frame first to set a starting point');
                    return;
                }

                // Binary search: current tolerance becomes min, new tolerance is midpoint
                settings.minTolerance = layer.tolerance;
                layer.tolerance = Math.ceil((settings.minTolerance + settings.maxTolerance) / 2);
                settings.tolerance = layer.tolerance;

                // Update UI for this layer
                const toolbar = this.layersContainer.querySelector(`[data-layer-id="${layerId}"]`);
                if (toolbar) {
                    const toleranceInput = toolbar.querySelector('.tolerance-input');
                    const minDisplay = toolbar.querySelector('.min-tolerance-display');
                    const maxDisplay = toolbar.querySelector('.max-tolerance-display');

                    if (toleranceInput) toleranceInput.value = layer.tolerance;
                    if (minDisplay) minDisplay.textContent = settings.minTolerance;
                    if (maxDisplay) maxDisplay.textContent = settings.maxTolerance;
                }

                // Reapply magic wand with new tolerance for current frame
                if (layerId === this.activeLayerId) {
                    this.performMagicWandCurrentFrame(settings.clickX, settings.clickY);
                }
            }

            markPerfectAndNextFrame(layerId) {
                const layer = this.layers.find(l => l.id === layerId);
                if (!layer) return;

                // Initialize layer frame settings if needed
                if (!layer.frameSettings) {
                    layer.frameSettings = {};
                }
                if (!layer.frameSettings[this.currentAnimation]) {
                    layer.frameSettings[this.currentAnimation] = {};
                }

                const settings = layer.frameSettings[this.currentAnimation][this.currentFrame];
                if (!settings || settings.clickX < 0) {
                    alert('Please click on the frame first to set a starting point');
                    return;
                }

                // Store the current pixel coordinates to select in the next frame
                const currentClickX = settings.clickX;
                const currentClickY = settings.clickY;

                // Move to next frame
                if (this.currentFrame < this.totalFrames - 1) {
                    this.setFrame(this.currentFrame + 1);
                } else {
                    // At last frame, show finished message
                    alert('Finished! You have completed all frames.');
                    return;
                }

                // Set this layer as active
                this.setActiveLayer(layerId);

                // Reset tolerance to 128 for the next frame
                layer.tolerance = 128;

                // After moving to the next frame, select the same pixel coordinates with reset tolerance
                this.selectPixelInCurrentFrame(currentClickX, currentClickY, 128);

                // Update UI to show reset tolerance values
                const toolbar = this.layersContainer.querySelector(`[data-layer-id="${layerId}"]`);
                if (toolbar) {
                    const toleranceInput = toolbar.querySelector('.tolerance-input');
                    const minDisplay = toolbar.querySelector('.min-tolerance-display');
                    const maxDisplay = toolbar.querySelector('.max-tolerance-display');

                    if (toleranceInput) toleranceInput.value = 128;
                    if (minDisplay) minDisplay.textContent = '0';
                    if (maxDisplay) maxDisplay.textContent = '255';

                    // Focus on the tolerance input
                    if (toleranceInput) {
                        toleranceInput.focus();
                    }
                }
            }

            selectPixelInCurrentFrame(imageX, imageY, tolerance = null) {
                // Programmatically select a pixel at the given coordinates
                const activeLayer = this.getActiveLayer();
                if (!activeLayer) return;

                // Use provided tolerance or current layer tolerance
                const useToleranceProgrammatic = tolerance !== null ? tolerance : activeLayer.tolerance;

                // Store settings for current frame with reset tolerance values
                this.saveCurrentFrameSettings(imageX, imageY, useToleranceProgrammatic, 0, 255);

                // Calculate screen coordinates for click indicator
                if (this.currentFrameElement) {
                    const imgRect = this.currentFrameElement.getBoundingClientRect();
                    const containerRect = this.framePreviewContainer.getBoundingClientRect();

                    // Convert image coordinates to screen coordinates
                    const scaleX = imgRect.width / this.frameWidth;
                    const scaleY = imgRect.height / this.frameHeight;

                    const screenX = imageX * scaleX;
                    const screenY = imageY * scaleY;

                    // Position relative to container
                    const containerX = screenX + (imgRect.left - containerRect.left);
                    const containerY = screenY + (imgRect.top - containerRect.top);

                    // Show click indicator
                    this.clickIndicator.style.left = containerX + 'px';
                    this.clickIndicator.style.top = containerY + 'px';
                    this.clickIndicator.style.display = 'block';

                    this.performMagicWandCurrentFrame(imageX, imageY);
                }
            }

            updateCurrentFrameSetting() {
                // Update tolerance for current frame without changing click position
                if (this.frameSettings[this.currentAnimation] &&
                    this.frameSettings[this.currentAnimation][this.currentFrame]) {
                    this.frameSettings[this.currentAnimation][this.currentFrame].tolerance = this.tolerance;
                }
            }

            updateToleranceRangeDisplay(minTolerance, maxTolerance) {
                this.minToleranceDisplay.textContent = minTolerance;
                this.maxToleranceDisplay.textContent = maxTolerance;
            }

            handleToleranceKeyDown(e) {
                if (e.key === 'PageUp') {
                    e.preventDefault();
                    const activeLayer = this.getActiveLayer();
                    if (activeLayer) {
                        this.adjustToleranceMore(activeLayer.id);
                    }
                } else if (e.key === 'PageDown') {
                    e.preventDefault();
                    const activeLayer = this.getActiveLayer();
                    if (activeLayer) {
                        this.adjustToleranceLess(activeLayer.id);
                    }
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    const activeLayer = this.getActiveLayer();
                    if (activeLayer) {
                        this.markPerfectAndNextFrame(activeLayer.id);
                    }
                }
            }

            performMagicWandCurrentFrame(clickX, clickY) {
                const activeLayer = this.getActiveLayer();
                if (!activeLayer) return;

                // Initialize layer masks for this animation if not exists
                if (!this.layerMasks[this.currentAnimation]) {
                    this.layerMasks[this.currentAnimation] = {};
                }
                if (!this.layerMasks[this.currentAnimation][this.currentFrame]) {
                    this.layerMasks[this.currentAnimation][this.currentFrame] = {};
                }

                // Perform magic wand selection only on current frame for active layer
                const frameImg = this.frameElements[this.currentAnimation]?.[this.currentFrame];
                if (!frameImg || !frameImg.complete) return;

                // Get existing masks from other layers for overlap prevention
                const otherLayerMasks = this.getOtherLayerMasks(activeLayer.id);

                const mask = this.createMagicWandMask(frameImg, clickX, clickY, activeLayer.tolerance, otherLayerMasks);
                this.layerMasks[this.currentAnimation][this.currentFrame][activeLayer.id] = mask;

                // Generate sprite only for current frame
                this.generateSpriteForFrame(this.currentFrame);
                this.updateFrame(); // Refresh display
            }

            getOtherLayerMasks(excludeLayerId) {
                const otherMasks = [];

                if (!this.layerMasks[this.currentAnimation] ||
                    !this.layerMasks[this.currentAnimation][this.currentFrame]) {
                    return otherMasks;
                }

                const frameMasks = this.layerMasks[this.currentAnimation][this.currentFrame];
                for (const layerId in frameMasks) {
                    if (parseInt(layerId) !== excludeLayerId) {
                        otherMasks.push(frameMasks[layerId]);
                    }
                }

                return otherMasks;
            }

            reapplyCurrentFrame() {
                // Reapply magic wand to current frame with current settings
                if (this.frameSettings[this.currentAnimation] &&
                    this.frameSettings[this.currentAnimation][this.currentFrame]) {
                    const settings = this.frameSettings[this.currentAnimation][this.currentFrame];
                    if (settings.clickX >= 0 && settings.clickY >= 0) {
                        this.performMagicWandCurrentFrame(settings.clickX, settings.clickY);
                    }
                }
            }


            createMagicWandMask(frameImg, clickX, clickY, tolerance, otherLayerMasks = []) {
                // Create temporary canvas to read pixel data
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = frameImg.naturalWidth || frameImg.width;
                tempCanvas.height = frameImg.naturalHeight || frameImg.height;

                tempCtx.drawImage(frameImg, 0, 0);
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

                // Get the color at the clicked position
                const startIndex = (clickY * tempCanvas.width + clickX) * 4;
                const startR = imageData.data[startIndex];
                const startG = imageData.data[startIndex + 1];
                const startB = imageData.data[startIndex + 2];
                const startA = imageData.data[startIndex + 3];

                // Create combined mask from other layers for overlap prevention
                const occupiedPixels = new Uint8Array(tempCanvas.width * tempCanvas.height);
                for (const otherMask of otherLayerMasks) {
                    if (otherMask && otherMask.mask &&
                        otherMask.width === tempCanvas.width &&
                        otherMask.height === tempCanvas.height) {
                        for (let i = 0; i < occupiedPixels.length; i++) {
                            if (otherMask.mask[i]) {
                                occupiedPixels[i] = 1;
                            }
                        }
                    }
                }

                // Create mask for selected pixels
                const mask = new Uint8Array(tempCanvas.width * tempCanvas.height);
                const visited = new Uint8Array(tempCanvas.width * tempCanvas.height);

                // Flood fill algorithm
                const stack = [{ x: clickX, y: clickY }];

                while (stack.length > 0) {
                    const { x, y } = stack.pop();

                    if (x < 0 || x >= tempCanvas.width || y < 0 || y >= tempCanvas.height) continue;

                    const index = y * tempCanvas.width + x;
                    if (visited[index]) continue;

                    // Skip pixels that are already occupied by other layers
                    if (occupiedPixels[index]) {
                        visited[index] = 1;
                        continue;
                    }

                    const pixelIndex = index * 4;
                    const r = imageData.data[pixelIndex];
                    const g = imageData.data[pixelIndex + 1];
                    const b = imageData.data[pixelIndex + 2];
                    const a = imageData.data[pixelIndex + 3];

                    // Check if color is similar enough
                    const colorDistance = Math.sqrt(
                        Math.pow(r - startR, 2) +
                        Math.pow(g - startG, 2) +
                        Math.pow(b - startB, 2)
                    );

                    if (colorDistance <= tolerance && a > 0) {
                        visited[index] = 1;
                        mask[index] = 1;

                        // Add neighboring pixels to stack
                        stack.push({ x: x + 1, y: y });
                        stack.push({ x: x - 1, y: y });
                        stack.push({ x: x, y: y + 1 });
                        stack.push({ x: x, y: y - 1 });
                    } else {
                        visited[index] = 1;
                    }
                }

                return {
                    mask: mask,
                    width: tempCanvas.width,
                    height: tempCanvas.height
                };
            }

            updateClickIndicatorPosition(imageX, imageY) {
                // Convert image coordinates back to screen coordinates and show indicator
                if (this.currentFrameElement && this.frameWidth > 0 && this.frameHeight > 0) {
                    const imgRect = this.currentFrameElement.getBoundingClientRect();
                    const containerRect = this.framePreviewContainer.getBoundingClientRect();

                    const scaleX = imgRect.width / this.frameWidth;
                    const scaleY = imgRect.height / this.frameHeight;

                    const screenX = imageX * scaleX + (imgRect.left - containerRect.left);
                    const screenY = imageY * scaleY + (imgRect.top - containerRect.top);

                    this.clickIndicator.style.left = screenX + 'px';
                    this.clickIndicator.style.top = screenY + 'px';
                    this.clickIndicator.style.display = 'block';
                }
            }


            generateAllSprites() {
                if (!this.spriteCanvases[this.currentAnimation]) {
                    this.spriteCanvases[this.currentAnimation] = {};
                }

                this.spriteCanvasContainer.innerHTML = '';

                for (let frameIndex = 0; frameIndex < this.totalFrames; frameIndex++) {
                    this.generateSpriteForFrame(frameIndex);
                }

                this.updateFrame();
            }

            generateSpriteForFrame(frameIndex) {
                const layerMasks = this.layerMasks[this.currentAnimation]?.[frameIndex];
                if (!layerMasks || Object.keys(layerMasks).length === 0) return;

                // Ensure sprite canvases container exists
                if (!this.spriteCanvases[this.currentAnimation]) {
                    this.spriteCanvases[this.currentAnimation] = {};
                }

                // Get frame dimensions from first available mask
                const firstMask = Object.values(layerMasks)[0];
                if (!firstMask) return;

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                canvas.className = 'sprite-canvas';
                canvas.width = firstMask.width;
                canvas.height = firstMask.height;
                canvas.style.display = 'none';
                canvas.style.imageRendering = 'pixelated';
                canvas.style.imageRendering = 'crisp-edges';

                // Create sprite image data
                const spriteImageData = ctx.createImageData(canvas.width, canvas.height);

                // Apply all layer masks in order (bottom layer first)
                for (const layer of this.layers) {
                    const layerMask = layerMasks[layer.id];
                    if (!layerMask) continue;

                    const targetRgb = hexToRgb(layer.color);

                    for (let i = 0; i < layerMask.mask.length; i++) {
                        const pixelIndex = i * 4;

                        if (layerMask.mask[i] === 1) {
                            // Selected pixel - paint with layer color
                            spriteImageData.data[pixelIndex] = targetRgb.r;
                            spriteImageData.data[pixelIndex + 1] = targetRgb.g;
                            spriteImageData.data[pixelIndex + 2] = targetRgb.b;
                            spriteImageData.data[pixelIndex + 3] = 255;
                        }
                    }
                }

                ctx.putImageData(spriteImageData, 0, 0);

                this.spriteCanvases[this.currentAnimation][frameIndex] = canvas;
                this.spriteCanvasContainer.appendChild(canvas);
            }

            updateVisibility() {
                if (this.currentFrameElement) {
                    if (this.showFrames) {
                        this.currentFrameElement.classList.add('active');
                    } else {
                        this.currentFrameElement.classList.remove('active');
                    }
                }

                if (this.currentSpriteCanvas) {
                    this.currentSpriteCanvas.style.opacity = this.spriteOpacity / 100;
                }
            }

            updateSpriteOpacity() {
                if (this.currentSpriteCanvas) {
                    this.currentSpriteCanvas.style.opacity = this.spriteOpacity / 100;
                }
            }

            updateAllSprites() {
                // Regenerate all sprites with current layer masks
                if (!this.layerMasks[this.currentAnimation]) {
                    return;
                }

                this.generateAllSprites();
            }


            setContainerDimensions() {
                if (this.frameWidth && this.frameHeight) {
                    // Always use the natural frame dimensions for the container
                    this.frameContainer.style.width = this.frameWidth + 'px';
                    this.frameContainer.style.height = this.frameHeight + 'px';
                }
            }

            switchAnimation(animationName) {
                if (animationName === this.currentAnimation) return;

                if (this.currentSpriteCanvas) {
                    this.currentSpriteCanvas.style.display = 'none';
                    this.currentSpriteCanvas = null;
                }

                this.currentAnimation = animationName;

                // Ensure animationData exists and has the animation
                if (!this.animationData) {
                    this.animationData = {};
                }

                if (this.animationData[animationName]) {
                    this.totalFrames = this.animationData[animationName].frameCount;
                } else {
                    // Create default animation data if it doesn't exist
                    this.animationData[animationName] = {
                        frameCount: 150,
                        frames: []
                    };
                    this.totalFrames = 150;
                }

                this.currentFrame = 0;

                this.frameSlider.max = this.totalFrames - 1;
                this.frameInput.max = this.totalFrames - 1;

                this.spriteCanvasContainer.innerHTML = '';

                // Clear magic wand state when switching animations
                this.clickIndicator.style.display = 'none';

                // Initialize magic wand data for new animation
                if (!this.layerMasks) {
                    this.layerMasks = {};
                }
                if (!this.layerMasks[animationName]) {
                    this.layerMasks[animationName] = {};
                }

                if (!this.frameSettings) {
                    this.frameSettings = {};
                }
                if (!this.frameSettings[animationName]) {
                    this.frameSettings[animationName] = {};
                }

                // Initialize tolerance settings for all frames in new animation
                this.initializeFrameSettings();

                this.frameWidth = 0;
                this.frameHeight = 0;

                this.createFrameElements();
                this.updateDisplays();
            }
        }

        let spriteTool;
        document.addEventListener('DOMContentLoaded', () => {
            spriteTool = new SpriteTool();
        });
    </script>
</body>

</html>