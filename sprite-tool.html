<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprite Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f0f0;
        }

        .container {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .back-btn {
            background-color: #6c757d;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 3px;
            cursor: pointer;
            text-decoration: none;
            font-size: 14px;
        }

        .back-btn:hover {
            background-color: #5a6268;
        }

        .animation-container {
            text-align: center;
            margin-bottom: 20px;
            background-color: #f8f8f8;
            padding: 20px;
            border-radius: 5px;
            position: relative;
        }

        .frame-preview-container {
            position: relative;
            display: inline-block;
            border: 2px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
        }

        #frame-container {
            position: relative;
            display: inline-block;
            min-width: 200px;
            min-height: 200px;
            width: auto;
            height: auto;
        }

        .frame-image {
            display: none;
            max-width: 100%;
            height: auto;
        }

        .frame-image.active {
            display: block;
        }

        .sprite-canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .sprite-canvas {
            position: absolute;
            top: -3px;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .animation-selector {
            margin-bottom: 10px;
        }

        .animation-selector select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }

        .control-group {
            background-color: #f8f8f8;
            padding: 15px;
            border-radius: 5px;
        }

        .control-group h3 {
            margin: 0 0 10px 0;
            color: #333;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .input-group label {
            min-width: 80px;
            font-weight: bold;
        }

        input[type="range"] {
            flex: 1;
        }

        input[type="number"] {
            width: 80px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }

        .play-pause-btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            width: 100%;
        }

        .play-pause-btn:hover {
            background-color: #0056b3;
        }

        .sprite-controls {
            background-color: #f8f8f8;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .sprite-controls h3 {
            margin: 0 0 15px 0;
            color: #333;
        }

        .color-mapping-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            margin-top: 15px;
            background-color: #ffffff;
        }

        .color-mapping-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 8px;
            border: 1px solid #eee;
            border-radius: 3px;
            background-color: #f9f9f9;
        }

        .color-mapping-item:last-child {
            margin-bottom: 0;
        }

        .source-color-preview {
            width: 30px;
            height: 30px;
            border: 1px solid #ccc;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .color-mapping-info {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .color-hex {
            font-family: monospace;
            font-size: 12px;
            font-weight: bold;
            color: #333;
        }

        .color-count {
            font-size: 11px;
            color: #666;
        }

        .target-color-picker {
            width: 40px;
            height: 30px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            flex-shrink: 0;
        }

        .color-mapping-controls {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
            background-color: #ffffff;
        }

        .color-mapping-controls h4 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 14px;
        }

        .sprite-button {
            background-color: #6f42c1;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .sprite-button:hover {
            background-color: #5a2d91;
        }

        .sprite-button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }

        .opacity-input {
            width: 60px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }

        .info {
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .info-item:last-child {
            margin-bottom: 0;
        }

        .info-label {
            font-weight: bold;
        }

        .sort-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }

        .sort-controls label {
            font-weight: bold;
            min-width: auto;
        }

        .sort-select {
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
            background-color: white;
        }

        .global-color-picker {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }

        .global-color-picker label {
            font-weight: bold;
            min-width: auto;
        }

        .global-color-input {
            width: 50px;
            height: 30px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        .color-mapping-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 8px;
            border: 1px solid #eee;
            border-radius: 3px;
            background-color: #f9f9f9;
            cursor: pointer;
        }

        .color-mapping-item:hover {
            background-color: #f0f0f0;
        }

        .color-mapping-item.selected {
            background-color: #e3f2fd;
            border-color: #2196f3;
        }

        .color-checkbox {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Sprite Tool</h1>
            <a href="index.html" class="back-btn">‚Üê Back to Tools</a>
        </div>

        <div class="animation-container">
            <div class="frame-preview-container">
                <div id="frame-container"></div>
                <div class="sprite-canvas-container" id="sprite-canvas-container"></div>
            </div>
        </div>

        <div class="animation-selector">
            <select id="animation-select">
                <option value="Walk">Walk</option>
            </select>
        </div>

        <div class="sprite-controls">
            <h3>Sprite Controls</h3>

            <div class="color-mapping-controls">
                <h4>Color Mapping</h4>

                <div class="input-group">
                    <button class="sprite-button" id="analyze-frames-btn">Extract Colors</button>
                    <button class="sprite-button" id="init-sprites-btn">Generate Sprites</button>
                </div>

                <div class="global-color-picker">
                    <label>Map selected colors to:</label>
                    <input type="color" id="global-color-input" class="global-color-input" value="#ff0000">
                    <span id="selected-count">0 colors selected</span>
                </div>

                <div class="sort-controls">
                    <label>Sort by:</label>
                    <select id="color-sort-select" class="sort-select">
                        <option value="frequency">Frequency (default)</option>
                        <option value="hue">Hue</option>
                        <option value="saturation">Saturation</option>
                        <option value="lightness">Lightness</option>
                    </select>
                </div>

                <div id="color-mapping-container" class="color-mapping-list">
                    <!-- Color mapping items will be dynamically inserted here -->
                </div>
            </div>

            <div class="input-group">
                <label>Sprite Opacity:</label>
                <input type="number" id="sprite-opacity-input" class="opacity-input" value="70" min="0" max="100" step="1">
                <span>%</span>
            </div>

            <div class="input-group">
                <label>
                    <input type="checkbox" id="show-frames-checkbox" checked>
                    Show Frames
                </label>
            </div>
        </div>

        <div class="control-group">
            <h3>Playback Controls</h3>
            <button class="play-pause-btn" id="play-pause-btn">Pause</button>

            <div class="input-group">
                <label>Frame:</label>
                <input type="range" id="frame-slider" min="0" max="149" value="0">
                <input type="number" id="frame-input" min="0" max="149" value="0">
            </div>

            <div class="input-group">
                <label>Elapsed Time:</label>
                <span id="elapsed-time-display">0.00s</span>
            </div>
        </div>

        <div class="control-group">
            <h3>Timing Settings</h3>
            <div class="input-group">
                <label>Delay (ms):</label>
                <input type="range" id="delay-slider" min="10" max="1000" value="30">
                <input type="number" id="delay-input" min="10" max="1000" value="30">
            </div>

            <div class="input-group">
                <label>FPS:</label>
                <span id="fps-display">33.3</span>
            </div>
        </div>

        <div class="info">
            <div class="info-item">
                <span class="info-label">Animation Frames:</span>
                <span id="current-animation-frames">150</span>
            </div>
            <div class="info-item">
                <span class="info-label">Animation Length:</span>
                <span id="total-length-display">4.50s</span>
            </div>
        </div>
    </div>

    <script>
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;

            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }

            return {
                h: Math.round(h * 360),
                s: Math.round(s * 100),
                l: Math.round(l * 100)
            };
        }

        function hexToHsl(hex) {
            const rgb = hexToRgb(hex);
            return rgb ? rgbToHsl(rgb.r, rgb.g, rgb.b) : null;
        }

        class SpriteTool {
            constructor() {
                this.currentFrame = 0;
                this.totalFrames = 150;
                this.delay = 30;
                this.isPlaying = true;
                this.animationId = null;
                this.currentAnimation = 'Walk';
                this.animations = [];
                this.animationData = {};

                this.frameWidth = 0;
                this.frameHeight = 0;
                this.frameElements = {};
                this.currentFrameElement = null;

                this.spriteCanvases = {};
                this.spriteData = {};
                this.currentSpriteCanvas = null;
                this.showFrames = true;
                this.spriteOpacity = 70;

                this.uniqueColors = {};
                this.colorMappings = {};
                this.selectedColors = {}; // Track selected colors per animation
                this.globalColor = '#ff0000';
                this.isAnalyzing = false;

                this.initializeElements();
                this.bindEvents();
                this.loadAvailableAnimations();
                this.startAnimation();
                this.updateDisplays();

                setTimeout(() => this.createFrameElements(), 100);
            }

            initializeElements() {
                this.frameContainer = document.getElementById('frame-container');
                this.playPauseBtn = document.getElementById('play-pause-btn');
                this.frameSlider = document.getElementById('frame-slider');
                this.frameInput = document.getElementById('frame-input');
                this.delaySlider = document.getElementById('delay-slider');
                this.delayInput = document.getElementById('delay-input');
                this.fpsDisplay = document.getElementById('fps-display');
                this.currentAnimationFrames = document.getElementById('current-animation-frames');
                this.totalLengthDisplay = document.getElementById('total-length-display');
                this.elapsedTimeDisplay = document.getElementById('elapsed-time-display');
                this.animationSelect = document.getElementById('animation-select');
                this.spriteOpacityInput = document.getElementById('sprite-opacity-input');
                this.initSpritesBtn = document.getElementById('init-sprites-btn');
                this.showFramesCheckbox = document.getElementById('show-frames-checkbox');
                this.spriteCanvasContainer = document.getElementById('sprite-canvas-container');
                this.analyzeFramesBtn = document.getElementById('analyze-frames-btn');
                this.colorMappingContainer = document.getElementById('color-mapping-container');
                this.colorSortSelect = document.getElementById('color-sort-select');
                this.globalColorInput = document.getElementById('global-color-input');
                this.selectedCountSpan = document.getElementById('selected-count');
            }

            bindEvents() {
                this.playPauseBtn.addEventListener('click', () => this.togglePlayPause());

                this.frameSlider.addEventListener('input', (e) => {
                    this.setFrame(parseInt(e.target.value));
                });

                this.frameInput.addEventListener('change', (e) => {
                    this.setFrame(parseInt(e.target.value));
                });

                this.delaySlider.addEventListener('input', (e) => {
                    this.setDelay(parseInt(e.target.value));
                });

                this.delayInput.addEventListener('change', (e) => {
                    this.setDelay(parseInt(e.target.value));
                });

                this.animationSelect.addEventListener('change', (e) => {
                    this.switchAnimation(e.target.value);
                });

                this.initSpritesBtn.addEventListener('click', () => {
                    this.initializeSprites();
                });

                this.showFramesCheckbox.addEventListener('change', (e) => {
                    this.showFrames = e.target.checked;
                    this.updateVisibility();
                });

                this.spriteOpacityInput.addEventListener('change', (e) => {
                    this.spriteOpacity = parseInt(e.target.value) || 0;
                    this.updateSpriteOpacity();
                });

                this.analyzeFramesBtn.addEventListener('click', () => {
                    this.extractAllColors();
                });

                this.colorSortSelect.addEventListener('change', () => {
                    this.createColorMappingUI();
                });

                this.globalColorInput.addEventListener('change', (e) => {
                    this.globalColor = e.target.value;
                    this.updateSelectedColorMappings();
                });
            }

            setFrame(frame) {
                this.currentFrame = Math.max(0, Math.min(frame, this.totalFrames - 1));
                this.updateFrame();
                this.updateDisplays();
            }

            setDelay(delay) {
                this.delay = Math.max(10, Math.min(delay, 1000));
                this.delaySlider.value = this.delay;
                this.delayInput.value = this.delay;
                this.updateDisplays();

                if (this.isPlaying) {
                    this.stopAnimation();
                    this.startAnimation();
                }
            }

            updateFrame() {
                if (this.currentFrameElement) {
                    this.currentFrameElement.classList.remove('active');
                }

                if (this.currentSpriteCanvas) {
                    this.currentSpriteCanvas.style.display = 'none';
                }

                if (this.frameElements[this.currentAnimation] &&
                    this.frameElements[this.currentAnimation][this.currentFrame]) {
                    this.currentFrameElement = this.frameElements[this.currentAnimation][this.currentFrame];
                    if (this.showFrames) {
                        this.currentFrameElement.classList.add('active');
                    }
                }

                if (this.spriteCanvases[this.currentAnimation] &&
                    this.spriteCanvases[this.currentAnimation][this.currentFrame]) {
                    this.currentSpriteCanvas = this.spriteCanvases[this.currentAnimation][this.currentFrame];
                    this.currentSpriteCanvas.style.display = 'block';
                    this.currentSpriteCanvas.style.opacity = this.spriteOpacity / 100;
                }
            }

            createFrameElements() {
                this.frameContainer.innerHTML = '';
                this.currentFrameElement = null;

                if (!this.frameElements[this.currentAnimation]) {
                    this.frameElements[this.currentAnimation] = {};
                }

                for (let frame = 0; frame < this.totalFrames; frame++) {
                    if (!this.frameElements[this.currentAnimation][frame]) {
                        const frameNumber = String(frame).padStart(3, '0');
                        const frameSrc = `Source/${this.currentAnimation}/frame_${frameNumber}_delay-0.03s.gif`;

                        const img = document.createElement('img');
                        img.className = 'frame-image';
                        img.src = frameSrc;
                        img.alt = `Frame ${frame}`;

                        if (frame === 0) {
                            img.onload = () => {
                                this.frameWidth = img.naturalWidth;
                                this.frameHeight = img.naturalHeight;
                                this.setContainerDimensions();
                            };
                        } else {
                            img.onload = () => {
                                if (!this.frameWidth || !this.frameHeight) {
                                    this.frameWidth = img.naturalWidth;
                                    this.frameHeight = img.naturalHeight;
                                    this.setContainerDimensions();
                                }
                            };
                        }

                        this.frameContainer.appendChild(img);
                        this.frameElements[this.currentAnimation][frame] = img;
                    }
                }

                this.updateFrame();
            }

            nextFrame() {
                this.currentFrame++;
                if (this.currentFrame >= this.totalFrames) {
                    this.currentFrame = 0;
                }
                this.updateFrame();
                this.updateDisplays();
            }

            togglePlayPause() {
                if (this.isPlaying) {
                    this.stopAnimation();
                } else {
                    this.startAnimation();
                }
            }

            startAnimation() {
                this.isPlaying = true;
                this.playPauseBtn.textContent = 'Pause';

                const animate = () => {
                    if (this.isPlaying) {
                        this.nextFrame();
                        this.animationId = setTimeout(animate, this.delay);
                    }
                };

                this.animationId = setTimeout(animate, this.delay);
            }

            stopAnimation() {
                this.isPlaying = false;
                this.playPauseBtn.textContent = 'Play';
                if (this.animationId) {
                    clearTimeout(this.animationId);
                    this.animationId = null;
                }
            }

            updateDisplays() {
                this.frameSlider.value = this.currentFrame;
                this.frameInput.value = this.currentFrame;

                const fps = (1000 / this.delay).toFixed(1);
                this.fpsDisplay.textContent = fps;

                this.currentAnimationFrames.textContent = this.totalFrames;
                const totalLength = (this.totalFrames * this.delay / 1000).toFixed(2);
                this.totalLengthDisplay.textContent = totalLength + 's';

                const elapsedTime = (this.currentFrame * this.delay / 1000).toFixed(2);
                this.elapsedTimeDisplay.textContent = elapsedTime + 's';
            }

            async loadAvailableAnimations() {
                try {
                    const response = await fetch('/api/animations');
                    const data = await response.json();

                    if (data.success) {
                        this.animations = data.animations.map(anim => anim.name);
                        this.animationData = {};

                        data.animations.forEach(anim => {
                            this.animationData[anim.name] = {
                                frameCount: anim.frameCount
                            };
                        });

                        if (this.animations.includes('Walk')) {
                            this.currentAnimation = 'Walk';
                        } else if (this.animations.length > 0) {
                            this.currentAnimation = this.animations[0];
                        }

                        if (this.currentAnimation && this.animationData[this.currentAnimation]) {
                            this.totalFrames = this.animationData[this.currentAnimation].frameCount;
                        }

                        this.updateAnimationSelect();
                    } else {
                        this.animations = ['Walk'];
                        this.animationData = { 'Walk': { frameCount: 150 } };
                        this.currentAnimation = 'Walk';
                        this.totalFrames = 150;
                        this.updateAnimationSelect();
                    }
                } catch (error) {
                    this.animations = ['Walk'];
                    this.animationData = { 'Walk': { frameCount: 150 } };
                    this.currentAnimation = 'Walk';
                    this.totalFrames = 150;
                    this.updateAnimationSelect();
                }
            }

            updateAnimationSelect() {
                this.animationSelect.innerHTML = '';
                this.animations.forEach(animation => {
                    const option = document.createElement('option');
                    option.value = animation;
                    option.textContent = animation;
                    if (animation === this.currentAnimation) {
                        option.selected = true;
                    }
                    this.animationSelect.appendChild(option);
                });
            }

            async extractAllColors() {
                if (this.isAnalyzing) return;

                this.isAnalyzing = true;
                this.analyzeFramesBtn.disabled = true;
                this.analyzeFramesBtn.textContent = 'Extracting...';

                try {
                    const colorMap = new Map();
                    let totalPixelsProcessed = 0;
                    const MAX_PIXELS = 500000;

                    for (let frame = 0; frame < this.totalFrames; frame++) {
                        const frameImg = this.frameElements[this.currentAnimation]?.[frame];
                        if (!frameImg || !frameImg.complete) {
                            continue;
                        }

                        const tempCanvas = document.createElement('canvas');
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCanvas.width = frameImg.naturalWidth || frameImg.width;
                        tempCanvas.height = frameImg.naturalHeight || frameImg.height;

                        tempCtx.drawImage(frameImg, 0, 0);
                        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

                        const step = Math.max(4, Math.floor(imageData.data.length / (4 * 5000)));

                        for (let i = 0; i < imageData.data.length && totalPixelsProcessed < MAX_PIXELS; i += step) {
                            const alpha = imageData.data[i + 3];
                            if (alpha > 0) {
                                const r = imageData.data[i];
                                const g = imageData.data[i + 1];
                                const b = imageData.data[i + 2];

                                const hex = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;

                                colorMap.set(hex, (colorMap.get(hex) || 0) + 1);
                                totalPixelsProcessed++;
                            }
                        }

                        if (totalPixelsProcessed >= MAX_PIXELS) {
                            break;
                        }
                    }

                    const uniqueColors = Array.from(colorMap.entries())
                        .map(([hex, count]) => ({ hex, count }))
                        .sort((a, b) => b.count - a.count);

                    this.uniqueColors[this.currentAnimation] = uniqueColors;

                    if (!this.colorMappings[this.currentAnimation]) {
                        this.colorMappings[this.currentAnimation] = {};
                    }

                    this.createColorMappingUI();
                    alert(`Color extraction complete! Found ${uniqueColors.length} unique colors.`);

                } catch (error) {
                    alert('Failed to extract colors: ' + error.message);
                } finally {
                    this.isAnalyzing = false;
                    this.analyzeFramesBtn.disabled = false;
                    this.analyzeFramesBtn.textContent = 'Extract Colors';
                }
            }

            createColorMappingUI() {
                const colors = this.uniqueColors[this.currentAnimation] || [];
                const container = this.colorMappingContainer;

                container.innerHTML = '';

                if (colors.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No colors found. Click "Extract Colors" first.</p>';
                    return;
                }

                // Initialize selected colors for this animation if not exists
                if (!this.selectedColors[this.currentAnimation]) {
                    this.selectedColors[this.currentAnimation] = new Set();
                }

                // Sort colors based on selected option
                const sortedColors = this.sortColors([...colors]);

                sortedColors.forEach((colorInfo, index) => {
                    const item = document.createElement('div');
                    item.className = 'color-mapping-item';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'color-checkbox';
                    checkbox.checked = this.selectedColors[this.currentAnimation].has(colorInfo.hex);

                    const sourcePreview = document.createElement('div');
                    sourcePreview.className = 'source-color-preview';
                    sourcePreview.style.backgroundColor = colorInfo.hex;

                    const info = document.createElement('div');
                    info.className = 'color-mapping-info';
                    info.innerHTML = `
                        <div class="color-hex">${colorInfo.hex}</div>
                        <div class="color-count">${colorInfo.count} pixels</div>
                    `;

                    // Update item appearance based on selection
                    if (checkbox.checked) {
                        item.classList.add('selected');
                    }

                    // Add event listeners
                    checkbox.addEventListener('change', (e) => {
                        this.toggleColorSelection(colorInfo.hex, e.target.checked);
                    });

                    item.addEventListener('click', (e) => {
                        if (e.target !== checkbox) {
                            checkbox.checked = !checkbox.checked;
                            this.toggleColorSelection(colorInfo.hex, checkbox.checked);
                        }
                    });

                    item.appendChild(checkbox);
                    item.appendChild(sourcePreview);
                    item.appendChild(info);
                    container.appendChild(item);
                });

                this.updateSelectedCount();
            }

            sortColors(colors) {
                const sortBy = this.colorSortSelect.value;

                switch (sortBy) {
                    case 'hue':
                        return colors.sort((a, b) => {
                            const hslA = hexToHsl(a.hex);
                            const hslB = hexToHsl(b.hex);
                            if (!hslA || !hslB) return 0;
                            return hslA.h - hslB.h;
                        });

                    case 'saturation':
                        return colors.sort((a, b) => {
                            const hslA = hexToHsl(a.hex);
                            const hslB = hexToHsl(b.hex);
                            if (!hslA || !hslB) return 0;
                            return hslB.s - hslA.s; // Descending (most saturated first)
                        });

                    case 'lightness':
                        return colors.sort((a, b) => {
                            const hslA = hexToHsl(a.hex);
                            const hslB = hexToHsl(b.hex);
                            if (!hslA || !hslB) return 0;
                            return hslA.l - hslB.l; // Ascending (darkest first)
                        });

                    case 'frequency':
                    default:
                        return colors.sort((a, b) => b.count - a.count); // Descending frequency
                }
            }

            toggleColorSelection(hex, isSelected) {
                if (!this.selectedColors[this.currentAnimation]) {
                    this.selectedColors[this.currentAnimation] = new Set();
                }

                if (isSelected) {
                    this.selectedColors[this.currentAnimation].add(hex);
                } else {
                    this.selectedColors[this.currentAnimation].delete(hex);
                }

                this.updateSelectedCount();
                this.updateSelectedColorMappings();
                this.updateColorItemAppearance();
            }

            updateSelectedCount() {
                const count = this.selectedColors[this.currentAnimation] ?
                    this.selectedColors[this.currentAnimation].size : 0;
                this.selectedCountSpan.textContent = `${count} color${count !== 1 ? 's' : ''} selected`;
            }

            updateColorItemAppearance() {
                const items = this.colorMappingContainer.querySelectorAll('.color-mapping-item');
                items.forEach(item => {
                    const checkbox = item.querySelector('.color-checkbox');
                    if (checkbox && checkbox.checked) {
                        item.classList.add('selected');
                    } else {
                        item.classList.remove('selected');
                    }
                });
            }

            updateSelectedColorMappings() {
                if (!this.colorMappings[this.currentAnimation]) {
                    this.colorMappings[this.currentAnimation] = {};
                }

                if (!this.selectedColors[this.currentAnimation]) {
                    return;
                }

                // Update mappings for selected colors
                this.selectedColors[this.currentAnimation].forEach(hex => {
                    this.colorMappings[this.currentAnimation][hex] = this.globalColor;
                });

                // Regenerate sprites if they exist
                if (this.spriteCanvases[this.currentAnimation] &&
                    Object.keys(this.spriteCanvases[this.currentAnimation]).length > 0) {
                    this.updateAllSprites();
                }
            }

            async initializeSprites() {
                this.initSpritesBtn.disabled = true;
                this.initSpritesBtn.textContent = 'Generating...';

                try {
                    if (!this.spriteCanvases[this.currentAnimation]) {
                        this.spriteCanvases[this.currentAnimation] = {};
                    }
                    if (!this.spriteData[this.currentAnimation]) {
                        this.spriteData[this.currentAnimation] = {};
                    }

                    this.spriteCanvasContainer.innerHTML = '';

                    for (let frame = 0; frame < this.totalFrames; frame++) {
                        await this.createSpriteForFrame(frame);
                    }

                    this.updateFrame();
                    alert(`Sprites generated for ${this.totalFrames} frames!`);

                } catch (error) {
                    alert('Failed to generate sprites: ' + error.message);
                } finally {
                    this.initSpritesBtn.disabled = false;
                    this.initSpritesBtn.textContent = 'Generate Sprites';
                }
            }

            async createSpriteForFrame(frameIndex) {
                return new Promise((resolve, reject) => {
                    const frameImg = this.frameElements[this.currentAnimation]?.[frameIndex];
                    if (!frameImg) {
                        reject(new Error(`Frame ${frameIndex} not found`));
                        return;
                    }

                    const processImage = () => {
                        try {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');

                            canvas.className = 'sprite-canvas';
                            canvas.width = frameImg.naturalWidth || frameImg.width;
                            canvas.height = frameImg.naturalHeight || frameImg.height;
                            canvas.style.display = 'none';

                            canvas.style.imageRendering = 'pixelated';
                            canvas.style.imageRendering = 'crisp-edges';

                            const tempCanvas = document.createElement('canvas');
                            const tempCtx = tempCanvas.getContext('2d');
                            tempCanvas.width = canvas.width;
                            tempCanvas.height = canvas.height;

                            tempCtx.drawImage(frameImg, 0, 0);

                            const imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
                            const spriteImageData = ctx.createImageData(canvas.width, canvas.height);

                            const colorMappings = this.colorMappings[this.currentAnimation] || {};

                            for (let i = 0; i < imageData.data.length; i += 4) {
                                const alpha = imageData.data[i + 3];
                                if (alpha > 0) {
                                    const r = imageData.data[i];
                                    const g = imageData.data[i + 1];
                                    const b = imageData.data[i + 2];

                                    const sourceHex = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;

                                    // Only show mapped colors, everything else is transparent
                                    if (colorMappings[sourceHex]) {
                                        const targetRgb = hexToRgb(colorMappings[sourceHex]);
                                        spriteImageData.data[i] = targetRgb.r;
                                        spriteImageData.data[i + 1] = targetRgb.g;
                                        spriteImageData.data[i + 2] = targetRgb.b;
                                        spriteImageData.data[i + 3] = 255;
                                    } else {
                                        // Unmapped colors are transparent
                                        spriteImageData.data[i + 3] = 0;
                                    }
                                } else {
                                    spriteImageData.data[i + 3] = 0;
                                }
                            }

                            ctx.putImageData(spriteImageData, 0, 0);

                            this.spriteCanvases[this.currentAnimation][frameIndex] = canvas;
                            this.spriteData[this.currentAnimation][frameIndex] = spriteImageData;

                            this.spriteCanvasContainer.appendChild(canvas);

                            resolve();
                        } catch (error) {
                            reject(error);
                        }
                    };

                    if (frameImg.complete && frameImg.naturalWidth > 0) {
                        processImage();
                    } else {
                        frameImg.onload = processImage;
                        frameImg.onerror = () => reject(new Error(`Failed to load frame ${frameIndex}`));
                    }
                });
            }

            updateVisibility() {
                if (this.currentFrameElement) {
                    if (this.showFrames) {
                        this.currentFrameElement.classList.add('active');
                    } else {
                        this.currentFrameElement.classList.remove('active');
                    }
                }

                if (this.currentSpriteCanvas) {
                    this.currentSpriteCanvas.style.opacity = this.spriteOpacity / 100;
                }
            }

            updateSpriteOpacity() {
                if (this.currentSpriteCanvas) {
                    this.currentSpriteCanvas.style.opacity = this.spriteOpacity / 100;
                }
            }

            async updateAllSprites() {
                if (!this.spriteCanvases[this.currentAnimation] || !this.colorMappings[this.currentAnimation]) {
                    return;
                }

                const colorMappings = this.colorMappings[this.currentAnimation];

                for (let frameIndex = 0; frameIndex < this.totalFrames; frameIndex++) {
                    const canvas = this.spriteCanvases[this.currentAnimation][frameIndex];
                    if (!canvas) continue;

                    const frameImg = this.frameElements[this.currentAnimation]?.[frameIndex];
                    if (!frameImg || !frameImg.complete) continue;

                    await this.updateSpriteForFrame(frameIndex, canvas, frameImg, colorMappings);
                }
            }

            async updateSpriteForFrame(frameIndex, canvas, frameImg, colorMappings) {
                return new Promise((resolve) => {
                    try {
                        const ctx = canvas.getContext('2d');

                        const tempCanvas = document.createElement('canvas');
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCanvas.width = frameImg.naturalWidth || frameImg.width;
                        tempCanvas.height = frameImg.naturalHeight || frameImg.height;

                        tempCtx.drawImage(frameImg, 0, 0);
                        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                        const spriteImageData = ctx.createImageData(canvas.width, canvas.height);

                        for (let i = 0; i < imageData.data.length; i += 4) {
                            const alpha = imageData.data[i + 3];
                            if (alpha > 0) {
                                const r = imageData.data[i];
                                const g = imageData.data[i + 1];
                                const b = imageData.data[i + 2];

                                const sourceHex = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;

                                // Only show mapped colors, everything else is transparent
                                if (colorMappings[sourceHex]) {
                                    const targetRgb = hexToRgb(colorMappings[sourceHex]);
                                    spriteImageData.data[i] = targetRgb.r;
                                    spriteImageData.data[i + 1] = targetRgb.g;
                                    spriteImageData.data[i + 2] = targetRgb.b;
                                    spriteImageData.data[i + 3] = 255;
                                } else {
                                    // Unmapped colors are transparent
                                    spriteImageData.data[i + 3] = 0;
                                }
                            } else {
                                spriteImageData.data[i + 3] = 0;
                            }
                        }

                        ctx.putImageData(spriteImageData, 0, 0);
                        resolve();
                    } catch (error) {
                        resolve();
                    }
                });
            }

            setContainerDimensions() {
                if (this.frameWidth && this.frameHeight) {
                    let displayedWidth, displayedHeight;

                    if (this.currentFrameElement && this.currentFrameElement.clientWidth > 0) {
                        displayedWidth = this.currentFrameElement.clientWidth;
                        displayedHeight = this.currentFrameElement.clientHeight;
                    } else {
                        const maxWidth = 400;
                        const maxHeight = 400;
                        const aspectRatio = this.frameWidth / this.frameHeight;

                        if (this.frameWidth > maxWidth || this.frameHeight > maxHeight) {
                            if (aspectRatio > 1) {
                                displayedWidth = maxWidth;
                                displayedHeight = maxWidth / aspectRatio;
                            } else {
                                displayedHeight = maxHeight;
                                displayedWidth = maxHeight * aspectRatio;
                            }
                        } else {
                            displayedWidth = this.frameWidth;
                            displayedHeight = this.frameHeight;
                        }
                    }

                    this.frameContainer.style.width = displayedWidth + 'px';
                    this.frameContainer.style.height = displayedHeight + 'px';
                }
            }

            switchAnimation(animationName) {
                if (animationName === this.currentAnimation) return;

                if (this.currentSpriteCanvas) {
                    this.currentSpriteCanvas.style.display = 'none';
                    this.currentSpriteCanvas = null;
                }

                this.currentAnimation = animationName;

                if (this.animationData[animationName]) {
                    this.totalFrames = this.animationData[animationName].frameCount;
                } else {
                    this.totalFrames = 150;
                }

                this.currentFrame = 0;

                this.frameSlider.max = this.totalFrames - 1;
                this.frameInput.max = this.totalFrames - 1;

                this.spriteCanvasContainer.innerHTML = '';

                // Initialize selected colors for new animation
                if (!this.selectedColors[animationName]) {
                    this.selectedColors[animationName] = new Set();
                }

                this.createColorMappingUI();

                this.frameWidth = 0;
                this.frameHeight = 0;

                this.createFrameElements();
                this.updateDisplays();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new SpriteTool();
        });
    </script>
</body>
</html>